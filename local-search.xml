<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker-基础篇</title>
    <link href="/2025/04/24/Docker-Docker%20%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2025/04/24/Docker-Docker%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Docker-简介与安装"><a href="#一-Docker-简介与安装" class="headerlink" title="一.Docker 简介与安装"></a>一.Docker 简介与安装</h1><p>Docker 两个主要部件：</p><ul><li>Docker: 开源的容器虚拟化平台：<a href="http://www.docker.com/">http://www.docker.com</a></li><li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – <a href="https://registry.hub.docker.com/search?q=library">Docker Hub</a></li></ul><p><strong>Docker 为什么出现？</strong></p><p>解决了<strong>运行环境和配置问题的软件容器</strong>，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="1-Docker-基本组成"><a href="#1-Docker-基本组成" class="headerlink" title="1. Docker 基本组成"></a>1. Docker 基本组成</h2><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。<strong>相当于容器的 “源代码”，docker 镜像文件类似于 Java 的类模板，而 docker 容器实例类似于 java 中 new 出来的实例对象。</strong></p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器和文件夹很类似，一个 Docker 容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。</p><h2 id="2-Docker-的安装"><a href="#2-Docker-的安装" class="headerlink" title="2. Docker 的安装"></a>2. Docker 的安装</h2><p>参考官方网站：<a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><p>以下操作均需要管理员权限，如果不是 root 角色下，需要在每条命令前加 sudo</p><ol><li>卸载旧版本</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure><p>安装需要的软件包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><p><strong>这里不能按照官网的操作，因为我们要设置自己的阿里云镜像仓库！！</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br></code></pre></td></tr></table></figure><p>更新 yum 软件包索引</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">yum install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-compose-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><p>启动 Docker、查看 docker 版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br>docker -v<br></code></pre></td></tr></table></figure><p>HelloWorld</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><h2 id="3-配置阿里云镜像加速"><a href="#3-配置阿里云镜像加速" class="headerlink" title="3. 配置阿里云镜像加速"></a>3. 配置阿里云镜像加速</h2><ol><li><p>注册一个阿里云账号，进入控制台，选择<strong>容器镜像服务</strong></p><p>2.直接复制粘贴官方的代码</p></li></ol><h2 id="4-底层原理"><a href="#4-底层原理" class="headerlink" title="4. 底层原理"></a>4. 底层原理</h2><p>为什么 docker 比 VM 虚拟机 快？</p><ol><li>docker 有着比虚拟机更少的抽象层<ul><li>由于 docker 不需要 Hypervisor (虚拟机) 实现硬件资源虚拟化，运行在 docker 容器上的程序<strong>直接使用的都是实际物理机的硬件资源</strong>。因此在 CPU、内存利用率上 docker 将会在效率上有明显优势。</li></ul></li><li>docker 利用的是宿主机的内核，而不需要加载操作系统 OS 内核<ul><li>当新建一个容器时，docker <strong>不需要和虚拟机一样重新加载一个操作系统内核</strong>。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载 OS, 返回新建过程是分钟级别的。而 <strong>docker 由于直接利用宿主机的操作系统</strong> , 则省略了返回过程，因此新建一个 docker 容器只需要几秒钟。</li></ul></li></ol><h1 id="二-Docker-常用命令"><a href="#二-Docker-常用命令" class="headerlink" title="二. Docker 常用命令"></a>二. Docker 常用命令</h1><h2 id="1-帮助启动类命令"><a href="#1-帮助启动类命令" class="headerlink" title="1. 帮助启动类命令"></a>1. 帮助启动类命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动 docker</td></tr><tr><td>systemctl stop docker</td><td>停止 docker</td></tr><tr><td>systemctl restart docker</td><td>重启 docker</td></tr><tr><td>systemctl status docker</td><td>查看 docker 状态</td></tr><tr><td>systemctl enable docker</td><td>开机启动</td></tr><tr><td>docker info</td><td>查看 docker 概要信息</td></tr><tr><td>docker –help</td><td>查看 docker 总体帮助文档</td></tr><tr><td>docker 具体命令 –help</td><td>查看 docker 命令帮助文档</td></tr></tbody></table><h2 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h2><table><thead><tr><th>命令</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>docker images</td><td>列出本地主机上的镜像</td><td><strong>-a</strong> : 列出本地所有的镜像 <strong>-q</strong> : 只显示镜像 ID。</td></tr><tr><td>docker search XXX</td><td>在仓库中搜索某个镜像</td><td><strong>–limit</strong> : 只列出 N 个镜像，默认 25 个</td></tr><tr><td>docker pull XXX:[tag]</td><td>下载某个镜像</td><td>没有 TAG 就是最新版</td></tr><tr><td>docker system df</td><td>查看镜像 &#x2F; 容器 &#x2F; 数据卷所占的空间</td><td>无</td></tr><tr><td>docker rmi XXX</td><td>删除某个镜像 （名字 &#x2F; ID）</td><td>-f 强制删除 ， 可以一次删除多个</td></tr><tr><td><strong>docker commit -m&#x3D;” 提交的描述信息” -a&#x3D;” 作者” 容器 ID 要创建的目标镜像名:[标签名]</strong></td><td><strong>提交容器副本使之成为一个新的镜像</strong></td><td></td></tr></tbody></table><h2 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h2><p><strong>有镜像才能创建容器，这是根本前提。</strong></p><table><thead><tr><th>命令</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></td><td>新建 + 启动容器</td><td><strong>–name&#x3D;”xxx”</strong>: 为容器指定一个名称； <strong>-d</strong>: 后台运行容器并返回容器 ID，也即启动守护式容器 (后台运行)； <strong>-i</strong>：以交互模式运行容器，通常与 -t 同时使用； <strong>-t</strong>：为容器重新分配一个伪输入终端，通常与 -i 同时使用； <strong>-P</strong>: 随机端口映射，大写 P <strong>-p</strong>: 指定端口映射，小写 p</td></tr><tr><td>docker ps [OPTIONS]</td><td>列出当前所有<strong>正在运行</strong>的容器</td><td><strong>-a</strong> : 列出当前所有正在运行的容器 + 历史上运行过的 <strong>-l</strong> : 显示最近创建的容器。 <strong>-n</strong>：显示最近 n 个创建的容器。 <strong>-q</strong> : 静默模式，只显示容器编号。</td></tr><tr><td>exit;ctrl+p+q</td><td>退出容器</td><td>exit 退出，容器停止；ctrl+p+q 退出，容器不停止</td></tr><tr><td>docker start ID&#x2F;name</td><td>启动已停止运行的容器</td><td></td></tr><tr><td>docker restart ID&#x2F;name</td><td>重启容器</td><td></td></tr><tr><td>docker stop ID&#x2F;name</td><td>停止容器</td><td></td></tr><tr><td>docker kill ID&#x2F;name</td><td>强制停止容器</td><td></td></tr><tr><td>docker rm ID</td><td>删除已停止的容器</td><td></td></tr><tr><td><strong>docker logs ID</strong></td><td><strong>查看容器日志</strong></td><td></td></tr><tr><td><strong>docker top ID</strong></td><td><strong>查看容器内运行的进程</strong></td><td></td></tr><tr><td><strong>docker inspect ID</strong></td><td><strong>查看容器内部细节</strong></td><td></td></tr><tr><td><strong>docker exec -it 容器 ID bashShell docker attach 容器 ID</strong></td><td><strong>进入正在运行的容器并以命令行交互</strong></td><td><strong>attach 直接进入容器启动命令的终端，不会启动新的进程，用 exit 退出，会导致容器的停止。 exec 是在容器中打开新的终端，并且可以启动新的进程用 exit 退出，不会导致容器的停止。（推荐）</strong></td></tr><tr><td><strong>docker cp 容器 ID: 容器内路径 目的主机路径</strong></td><td><strong>从容器内拷贝文件到主机上</strong></td><td></td></tr><tr><td><strong>docker export 容器 ID &gt; 文件名.tar</strong></td><td><strong>导出容器</strong></td><td></td></tr><tr><td><strong>cat 文件名.tar | docker import - 镜像用户 &#x2F; 镜像名：镜像版本号</strong></td><td><strong>导入容器</strong></td><td></td></tr></tbody></table><h1 id="三-Docker-容器数据卷"><a href="#三-Docker-容器数据卷" class="headerlink" title="三. Docker 容器数据卷"></a>三. Docker 容器数据卷</h1><p>类似 Redis 的 rdb 和 aof 文件，类似 Linux 虚拟机和 win 宿主机共享文件夹。<strong>将 docker 容器内的数据保存进宿主机的磁盘中</strong>，<strong>运行一个带有容器卷存储功能的容器实例</strong>。</p><h2 id="1-宿主和容器间映射添加容器卷"><a href="#1-宿主和容器间映射添加容器卷" class="headerlink" title="1. 宿主和容器间映射添加容器卷"></a>1. 宿主和容器间映射添加容器卷</h2><p>通过命令直接挂载</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录   镜像名<br></code></pre></td></tr></table></figure><p>查看数据卷是否挂载成功</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器ID<br></code></pre></td></tr></table></figure><p>此时在宿主机或容器的对应挂载目录中修改数据都是同步的。</p><h2 id="2-读写规则映射添加"><a href="#2-读写规则映射添加" class="headerlink" title="2. 读写规则映射添加"></a>2. 读写规则映射添加</h2><ul><li>读写（默认）：re<ul><li>docker run -it –privileged&#x3D;true -v &#x2F; 宿主机绝对路径目录:&#x2F; 容器内目录 镜像名</li></ul></li><li>只读：ro<ul><li>docker run -it –privileged&#x3D;true -v &#x2F; 宿主机绝对路径目录:&#x2F; 容器内目录:rw 镜像名</li></ul></li></ul><p>设置了只读之后，在容器中就无法写入内容了。</p><p>此时如果<strong>宿主机写入内容，可以同步给容器内，容器可以读取到</strong>。</p><h1 id="四-Docker-常规安装简介"><a href="#四-Docker-常规安装简介" class="headerlink" title="四.Docker 常规安装简介"></a>四.Docker 常规安装简介</h1><p>总体步骤：</p><ul><li>搜索镜像<ul><li>docker seacher xxx</li></ul></li><li>拉取镜像<ul><li>docker pull xxx</li></ul></li><li>查看镜像<ul><li>docker images</li></ul></li><li>启动镜像<ul><li>服务端口映射</li><li>docker run -it -p xxxx:xxxx xxx</li></ul></li><li>停止容器<ul><li>docker stop xxx</li></ul></li><li>移除容器<ul><li>docker rm xxx(ID)</li></ul></li></ul><p>相关的应用安装参考：</p><ul><li><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.w3cschool.cn/docker/">Docker 教程_w3cschool</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker国内镜像源配置</title>
    <link href="/2025/01/21/Docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/21/Docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/docker<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerproxy.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.nju.edu.cn&quot;</span><br>    ]<br>&#125;<br>EOF<br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>(1)如果要删除 <code>/etc/docker/daemon.json </code>文件，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -f /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>(2)如果要手动编辑 <code>/etc/docker/daemon.json </code>文件,可以进行以下手动编辑 daemon.json 的步骤：</p><p>1.使用<code>vim</code>编辑器编辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p> 2.保存并退出:</p><p>输入Esc+ :wq 并按 Enter  (强制保存则+:wq!)</p><p>3.重启 Docker 服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="汇总国内可用镜像"><a href="#汇总国内可用镜像" class="headerlink" title="汇总国内可用镜像"></a>汇总国内可用镜像</h2><h3 id="DaoCloud-镜像站"><a href="#DaoCloud-镜像站" class="headerlink" title="DaoCloud 镜像站"></a>DaoCloud 镜像站</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://docker.m.daocloud.io">https://docker.m.daocloud.io</a></p><p>支持：Docker Hub、GCR、K8S、GHCR、Quay、NVCR 等</p><p>对外免费：是</p><h3 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></p><p>支持：Docker Hub</p><p>对外免费：是</p><h3 id="Docker-镜像代理"><a href="#Docker-镜像代理" class="headerlink" title="Docker 镜像代理"></a>Docker 镜像代理</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://dockerproxy.com">https://dockerproxy.com</a></p><p>支持：Docker Hub、GCR、K8S、GHCR</p><p>对外免费：是</p><h3 id="百度云"><a href="#百度云" class="headerlink" title="百度云"></a>百度云</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://mirror.baidubce.com">https://mirror.baidubce.com</a></p><p>支持：Docker Hub</p><p>对外免费：是</p><h3 id="南京大学镜像站"><a href="#南京大学镜像站" class="headerlink" title="南京大学镜像站"></a>南京大学镜像站</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://docker.nju.edu.cn">https://docker.nju.edu.cn</a></p><p>支持：Docker Hub、GCR、GHCR、Quay、NVCR 等</p><p>对外免费：是</p><h3 id="上海交大镜像站"><a href="#上海交大镜像站" class="headerlink" title="上海交大镜像站"></a>上海交大镜像站</h3><p>加速地址：<a href="https://link.zhihu.com/?target=https://docker.mirrors.sjtug.sjtu.edu.cn/">https://docker.mirrors.sjtug.sjtu.edu.cn/</a></p><p>支持：Docker Hub、GCR 等</p><p>限制：无</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署MySQL并实现远程连接</title>
    <link href="/2025/01/20/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-Docker%E9%83%A8%E7%BD%B2MySQL/"/>
    <url>/2025/01/20/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-Docker%E9%83%A8%E7%BD%B2MySQL/</url>
    
    <content type="html"><![CDATA[<p><strong>1.编写好dockerfile文件</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#指定基础镜像</span><br><span class="hljs-keyword">FROM</span> mysql:latest<br><br><span class="hljs-comment">#设置初始环境变量</span><br><span class="hljs-keyword">ENV</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span><br><br><span class="hljs-keyword">ENV</span> MYSQL_DATABASE=database<br><br><span class="hljs-comment">#用于将初始化脚本 init.sql 复制到 MySQL 容器的 /docker-entrypoint-initdb.d/ 目录中。当 #MySQL 容器启动时，它会自动执行该目录下的所有 SQL 脚本文件，从而完成数据库的初始化。</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> init.sql /docker-entrypoint-initdb.d/</span><br><br><span class="hljs-comment">#EXPOSE指令用于在Dockerfile中声明容器在运行时监听的网络端口，但它并不会自动暴露端口，也不会将容</span><br><span class="hljs-comment">#器内部的端口映射到宿主机上。其主要作用是提供一种方式，让开发者和其他人能够清楚地了解该容器需要开</span><br><span class="hljs-comment">#放哪些端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span> <br></code></pre></td></tr></table></figure><p><strong>2.创建容器并运行</strong></p><p>这里先切换到了我自己的MySQLDocker目录</p><p> <img src="/img/articles/18.png"> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> MySQLDocker<br></code></pre></td></tr></table></figure><p>（1）以下命令用于从当前目录下的 Dockerfile 构建一个新的 Docker 镜像，并将其命名为 <code>mysql-image</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker build -t mysql-image .<br></code></pre></td></tr></table></figure><h6 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h6><ul><li>**<code>docker build</code>**：<ul><li>这是 Docker 的一个命令，用于根据 Dockerfile 构建一个新的镜像。</li></ul></li><li>**<code>-t mysql-image</code>**：<ul><li><code>-t</code> 是 <code>--tag</code> 的简写，用于为构建的镜像指定一个名称（和可选的标签）。在这里，镜像的名称是 <code>mysql-image</code>。如果想指定一个标签（例如版本号），可以写成 <code>-t mysql-image:1.0</code>。</li></ul></li><li>**<code>.</code>**：<ul><li>表示当前目录。Docker 会在这个目录下查找 <code>Dockerfile</code>，并使用它来构建镜像。这个目录也被称为构建上下文（build context）。Docker 会将当前目录下的文件和文件夹发送到 Docker 守护进程，因此确保当前目录中包含所有需要的文件（如 <code>Dockerfile</code> 和初始化脚本）。</li></ul></li></ul><p>（2）以下命令用于从 <code>mysql-image</code> 镜像创建并启动一个新的 Docker 容器，并将其命名为 <code>mysql-container</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql-container -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -d mysql-image<br></code></pre></td></tr></table></figure><h6 id="详细解释：-1"><a href="#详细解释：-1" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h6><ul><li>**<code>docker run</code>**：<ul><li>用于创建并启动一个新的 Docker 容器。</li></ul></li><li>**<code>--name mysql-container</code>**：<ul><li>为容器指定一个名称（<code>mysql-container</code>），便于后续操作。</li></ul></li><li>**<code>-p 3306:3306</code>**：<ul><li>将容器的 3306 端口映射到宿主机的 3306 端口。这意味着可以从宿主机或其他机器通过 <code>宿主机IP:3306</code> 访问容器中的 MySQL 服务。</li><li>格式为 <code>-p 宿主机端口:容器端口</code>。</li></ul></li><li>**<code>-d mysql-image</code>**：<ul><li><code>-d</code> 表示以 <strong>detached</strong> 模式运行容器（即在后台运行）。</li><li><code>mysql-image</code> 是刚刚构建的镜像名称，Docker 将使用它来创建容器。</li></ul></li></ul><p><strong>3.进入正在运行的 <code>mysql-container</code> 容器和进入 MySQL 的交互式命令行界面</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">exec</span> -it mysql-<span class="hljs-keyword">container</span> mysql -uroot -p123456<br></code></pre></td></tr></table></figure><h6 id="详细解释：-2"><a href="#详细解释：-2" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h6><ul><li>**<code>docker exec</code>**：<ul><li>用于在正在运行的容器中执行命令。</li></ul></li><li>**<code>-it</code>**：<ul><li><code>-i</code> 表示交互式模式，允许用户与容器内的命令交互。</li><li><code>-t</code> 分配一个伪终端，使用户能够像在本地终端中一样操作。</li></ul></li><li>**<code>mysql-container</code>**：<ul><li>指定目标容器的名称（即之前创建的 <code>mysql-container</code>）。</li></ul></li><li>**<code>mysql -uroot -p123456</code>**：<ul><li>在容器内执行的命令，用于启动 MySQL 客户端。</li><li><code>-u root</code> 表示以 <code>root</code> 用户登录 MySQL。</li><li><code>-p123456</code> 表示 <code>root</code> 用户的密码是 <code>123456</code>。</li></ul></li></ul><p><strong>4.创建数据库用户并配置实现远程连接</strong>(MySQL 8.0及以上)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> hhh@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> hhh@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; flush <span class="hljs-keyword">privileges</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网站部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>做了一个接入AI的AI问答助手APP</title>
    <link href="/2025/01/10/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8E%A5%E5%85%A5AI/"/>
    <url>/2025/01/10/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8E%A5%E5%85%A5AI/</url>
    
    <content type="html"><![CDATA[<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a><strong>具体实现：</strong></h2><p>1.在Android应用的<code>AndroidManifest.xml</code>文件中添加网络访问权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>在build.gradle中添加必要的依赖（使用http请求api）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">implementation</span> <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:4.9.3&#x27;</span><br></code></pre></td></tr></table></figure><p>2.创建一个新的类以处理文心一言的API信息：<strong>WenXin.java</strong>，在<strong>Activity</strong>里需要实现文心一言的对话功能只需调用这个类就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapp.config;<br><br><span class="hljs-keyword">import</span> org.json.JSONArray;<br><span class="hljs-keyword">import</span> org.json.JSONException;<br><span class="hljs-keyword">import</span> org.json.JSONObject;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">import</span> okhttp3.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主要用于实现对接千帆大模型API的功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AiConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> String API_KEY;<br><br>    <span class="hljs-keyword">public</span> String SECRET_KEY;<br><br>    <span class="hljs-keyword">public</span> String AI_Role;<br><br>    <span class="hljs-keyword">public</span> JSONArray Dialogue_Content;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AiConfig类的初始化设置，设置好apikey等参数，以向服务器发送信息，airole参数的作用是自定义ai助手的角色功能类型</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AiConfig</span><span class="hljs-params">(String apikey, String secrectkey, String airole)</span>&#123;<br>        Dialogue_Content=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        API_KEY=apikey;<br>        SECRET_KEY=secrectkey;<br>        AI_Role=airole;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">HTTP_CLIENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder().connectTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS).writeTimeout(<span class="hljs-number">60</span>, TimeUnit.SECONDS).readTimeout(<span class="hljs-number">60</span>, TimeUnit.SECONDS).build();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetAnswer</span><span class="hljs-params">(String user_msg,<span class="hljs-keyword">final</span> ResponseCallback callback)</span> <span class="hljs-keyword">throws</span> IOException, JSONException&#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        jsonObject.put(<span class="hljs-string">&quot;role&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;content&quot;</span>, user_msg);<br><br>        Dialogue_Content.put(jsonObject);<br>        <span class="hljs-type">MediaType</span> <span class="hljs-variable">mediaType</span> <span class="hljs-operator">=</span> MediaType.parse(<span class="hljs-string">&quot;application/json&quot;</span>);<br>        <span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> RequestBody.create(mediaType, <span class="hljs-string">&quot;&#123;\&quot;messages\&quot;:&quot;</span> + Dialogue_Content.toString() + <span class="hljs-string">&quot;,\&quot;system\&quot;:\&quot;&quot;</span> + AI_Role + <span class="hljs-string">&quot;\&quot;,\&quot;disable_search\&quot;:false,\&quot;enable_citation\&quot;:false&#125;&quot;</span>);<br><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder().url(<span class="hljs-string">&quot;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/ernie-speed-128k?access_token=&quot;</span> + getAccessToken()).method(<span class="hljs-string">&quot;POST&quot;</span>, body).addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).build();<br><br>        HTTP_CLIENT.newCall(request).enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, Response response)</span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (response.isSuccessful()) &#123;<br>                        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">json_feedback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(response.body().string());<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> json_feedback.getString(<span class="hljs-string">&quot;result&quot;</span>);<br>                        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsontmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>                        jsontmp.put(<span class="hljs-string">&quot;assistant&quot;</span>, res);<br>                        Dialogue_Content.put(jsontmp);<br>                        callback.onSuccess(res);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        callback.onError(<span class="hljs-string">&quot;服务器返回错误：&quot;</span> + response.code());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    callback.onError(e.getMessage());<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>                callback.onError(e.getMessage());<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从用户的AK，SK生成鉴权签名（Access Token）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAccessToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, JSONException &#123;<br>        <span class="hljs-type">MediaType</span> <span class="hljs-variable">mediaType</span> <span class="hljs-operator">=</span> MediaType.parse(<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>        <span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> RequestBody.create(mediaType, <span class="hljs-string">&quot;grant_type=client_credentials&amp;client_id=&quot;</span> + API_KEY + <span class="hljs-string">&quot;&amp;client_secret=&quot;</span> + SECRET_KEY);<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder().url(<span class="hljs-string">&quot;https://aip.baidubce.com/oauth/2.0/token&quot;</span>).method(<span class="hljs-string">&quot;POST&quot;</span>, body).addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>).build();<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> HTTP_CLIENT.newCall(request).execute();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(response.body().string()).getString(<span class="hljs-string">&quot;access_token&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 回调接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResponseCallback</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String response)</span>;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(String error)</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3.在Activity中这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapp.activity;<br><br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.content.SharedPreferences;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Handler;<br><span class="hljs-keyword">import</span> android.os.Looper;<br><span class="hljs-keyword">import</span> android.os.Message;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><span class="hljs-keyword">import</span> android.widget.EditText;<br><span class="hljs-keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager;<br><span class="hljs-keyword">import</span> androidx.recyclerview.widget.RecyclerView;<br><span class="hljs-keyword">import</span> com.airbnb.lottie.LottieAnimationView;<br><span class="hljs-keyword">import</span> com.example.myapp.config.AiConfig;<br><span class="hljs-keyword">import</span> com.example.myapp.model.Chatlist;<br><span class="hljs-keyword">import</span> com.example.myapp.R;<br><span class="hljs-keyword">import</span> com.example.myapp.adapter.ChatlistAdapter;<br><span class="hljs-keyword">import</span> org.json.JSONException;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EditText et_chat;<br><br>    <span class="hljs-keyword">private</span> Button btn_send,btn_chat_return;<br><br>    <span class="hljs-keyword">private</span> ChatlistAdapter chatAdapter;<br><br>    <span class="hljs-keyword">private</span> List&lt;Chatlist&gt; mDatas;<br><br>    <span class="hljs-keyword">private</span> SharedPreferences preferences;<br><br>    <span class="hljs-keyword">private</span> RecyclerView rc_chatlist;<br><br>    <span class="hljs-keyword">private</span> LottieAnimationView lo_msgloading;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MESSAGE_UPDATE_VIEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_chat);<br>        init();<br>        mDatas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//读取用户设置里的千帆大模型的API_Key等信息,这里设置了我自己的密钥</span><br>        preferences= <span class="hljs-built_in">this</span>.getSharedPreferences(<span class="hljs-string">&quot;usersetting&quot;</span>,MODE_PRIVATE);<br>        String apikey=preferences.getString(<span class="hljs-string">&quot;API_Key&quot;</span>,<span class="hljs-string">&quot;w******je**********lhG9W&quot;</span>);<br>        String secretkey=preferences.getString(<span class="hljs-string">&quot;Secret_Key&quot;</span>,<span class="hljs-string">&quot;wRU******HV6LSW************XX6h3&quot;</span>);<br>        String airole=preferences.getString(<span class="hljs-string">&quot;Role&quot;</span>,<span class="hljs-string">&quot;你的名字是AI Assistant，你是解答用户问题的小助手，使用中文进行回答&quot;</span>);<br><br>        chatAdapter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatlistAdapter</span>(<span class="hljs-built_in">this</span>,mDatas);<br><br>        <span class="hljs-type">LinearLayoutManager</span> <span class="hljs-variable">layoutManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(<span class="hljs-built_in">this</span> );<br>        rc_chatlist.setLayoutManager(layoutManager);<br>        rc_chatlist.setHasFixedSize(<span class="hljs-literal">true</span>);<br>        rc_chatlist.setAdapter(chatAdapter);<br>        btn_send.setOnClickListener(v -&gt; &#123;<br>            btn_send.setVisibility(View.GONE);<span class="hljs-comment">//点击发送按钮之后，按钮会隐藏</span><br>            lo_msgloading.setVisibility(View.VISIBLE);<br>            <span class="hljs-comment">//用户的提问</span><br>            String user_ask=et_chat.getText().toString();<span class="hljs-comment">//获取输入框里的信息</span><br>            Chatlist CC;<br>            CC=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Chatlist</span>(<span class="hljs-string">&quot;USER&quot;</span>,user_ask);<br>            mDatas.add(CC);<br><br>            chatAdapter.ResetChatlistAdapter(mDatas);<br>            rc_chatlist.setAdapter(chatAdapter);<br>            AiConfig AI=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AiConfig</span>(apikey,secretkey,airole);<br>            <span class="hljs-comment">//千帆大模型的回答</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">//请求详情</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    AI.GetAnswer(user_ask, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AiConfig</span>.ResponseCallback() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String response)</span> &#123;<br>                            <span class="hljs-comment">// 在这里处理获取到的结果</span><br>                            Chatlist CD;<br>                            String AIresult=response.toString();<br>                            CD=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Chatlist</span>(<span class="hljs-string">&quot;AI Assistant&quot;</span>,AIresult);<br><br>                            mDatas.add(CD);<br>                            chatAdapter.ResetChatlistAdapter(mDatas);<br><br>                            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>                            msg.what = MESSAGE_UPDATE_VIEW;<br>                            ChatActivity.<span class="hljs-built_in">this</span>.gHandler.sendMessage(msg);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(String error)</span> &#123;<br>                            <span class="hljs-comment">// 在这里处理错误情况</span><br>                            Chatlist CF;<br>                            String AIresult=<span class="hljs-string">&quot;获取信息失败&quot;</span>;<br>                            CF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Chatlist</span>(<span class="hljs-string">&quot;AI Assistant&quot;</span>,AIresult);<br><br>                            mDatas.add(CF);<br>                            chatAdapter.ResetChatlistAdapter(mDatas);<br><br>                            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>                            msg.what = MESSAGE_UPDATE_VIEW;<br>                            ChatActivity.<span class="hljs-built_in">this</span>.gHandler.sendMessage(msg);<br>                        &#125;<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br><br>            &#125;).start();<br><br>        &#125;);<br>        btn_chat_return.setOnClickListener(v -&gt; &#123;<br>            Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(ChatActivity.<span class="hljs-built_in">this</span>, MainActivity.class);<br>            startActivity(intent);<br>            ChatActivity.<span class="hljs-built_in">this</span>.finish();<br>        &#125;);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        btn_send=findViewById(R.id.btn_send);<br>        et_chat=findViewById(R.id.et_chat);<br>        btn_chat_return=findViewById(R.id.btn_chat_return);<br>        rc_chatlist=findViewById(R.id.rc_chatlist);<br>        lo_msgloading=findViewById(R.id.lo_msgloading);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">gHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">if</span> (msg.what == MESSAGE_UPDATE_VIEW) &#123;<br>                rc_chatlist.setAdapter(chatAdapter);<br>                btn_send.setVisibility(View.VISIBLE);<span class="hljs-comment">//恢复按钮</span><br>                lo_msgloading.setVisibility(View.INVISIBLE);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p> <img src="/img/articles/20.png"> </p><p> <img src="/img/articles/21.png"> </p><p> <img src="/img/articles/22.png"> </p>]]></content>
    
    
    <categories>
      
      <category>AI大模型接入</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运行安卓项目通用配置（java）</title>
    <link href="/2024/12/29/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/12/29/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p> <img src="/img/articles/Android/1.jpg"> </p><p> <img src="/img/articles/Android/2.jpg"> </p><p> <img src="/img/articles/Android/3.jpg"> </p><p> <img src="/img/articles/Android/4.jpg"> </p><p> <img src="/img/articles/Android/5.jpg"> </p><p> <img src="/img/articles/Android/6.jpg"> </p>]]></content>
    
    
    <categories>
      
      <category>配置各类环境所遇问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis 的 Java 客户端</title>
    <link href="/2024/12/26/Redis-Redis%20%E7%9A%84%20Java%20%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2024/12/26/Redis-Redis%20%E7%9A%84%20Java%20%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>目前我了解到的有以下 4 种。</p><ul><li>Spring-Data-Redis：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></li><li>Jedis：<a href="https://github.com/redis/jedis/wiki">https://github.com/redis/jedis/wiki</a></li><li>Lettuce：<a href="https://lettuce.io/">https://lettuce.io/</a> ，这里不做介绍，太高级了，估计 hold 不住。</li><li>Redisson ：<a href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></li></ul><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>SpringData 是 Spring 中数据操作的模块，包含对各种数据库的集成，相当于定义了一些如增删改查的抽象接口，继而有对应不同数据库的实现。</p><ul><li><a href="https://spring.io/projects/spring-data-jdbc">Spring Data JDBC</a></li><li><a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a></li><li><a href="https://spring.io/projects/spring-data-mongodb">Spring Data MongoDB</a></li><li><a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a></li><li>。。。</li></ul><p>其中对 redis 集成模块就叫做 Spring Data Redis。</p><ul><li>提供了对不同 Redis 客户端的整合（Lettuce 和 Jedis）</li><li>提供了 RedisTemplate 统一 API 来操作 Redis</li><li>支持 Redis 的发布订阅模型</li><li>支持 Redis 哨兵和 Redis 集群</li><li>支持基于 Lettuce 的响应式编程</li><li>支持基于 JDK.JSON. 字符串.Spring 对象的数据序列化及反序列化</li><li>支持基于 Redis 的 JDKCollection 实现</li></ul><p>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">      <span class="hljs-comment">&lt;!--连接池依赖--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-编写配置文件"><a href="#2-2-编写配置文件" class="headerlink" title="2.2 编写配置文件"></a>2.2 编写配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">yourPassword</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span><br></code></pre></td></tr></table></figure><h3 id="2-3-测试与问题"><a href="#2-3-测试与问题" class="headerlink" title="2.3 测试与问题"></a>2.3 测试与问题</h3><p>可以看到是可以正常写入和获取的，那么我们来看看数据库。</p><p>发现问题：</p><ol><li>插入进来的怎么不是 “coderbin”，多了前面一坨东西呢？</li><li>为什么查不到值呢？</li></ol><p>追溯问题：</p><p><strong>RedisTemplate 可以接收任意 Object 作为值写入 Redis，只不过写入前会把 Object 序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果就是上图所示</strong></p><p>简单方法：直接不用 RedisTemplate，我们用 <strong>StringRedisTemplate.</strong></p><p>正常输出，再去看数据库。</p><p>键值的数据也是正常的，但是！这里又有问题。</p><p>stringRedisTemplate 的 set 方法要求键值都为 string 类型，这就无法满足我们的需求。</p><p><strong>那么我们就要自定义 RedisTemplate 的序列化方式啦！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到已经大功告成了。</p><p>总结一下：</p><p>RedisTemplate 的两种序列化实践方案：</p><ul><li>方案一：<ul><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ul></li><li>方案二：<ul><li>使用 StringRedisTemplate</li><li>写入 Redis 时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ul></li></ul><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p><a href="https://blog.csdn.net/zhangguanghui002/article/details/78770071">(25 条消息) Jedis 常用方法 API_遛狗大师的博客 - CSDN 博客_jedis 方法</a></p><p>使用<strong>阻塞的 I&#x2F;O，且其方法调用都是同步的（慢！）</strong>，程序流需要等到 sockets 处理完 I&#x2F;O 才能执行，不支持异步。Jedis 客户端实例不是线程安全的，所以需要通过连接池来使用 Jedis。</p><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><h3 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-创建连接池"><a href="#1-2-创建连接池" class="headerlink" title="1.2 创建连接池"></a>1.2 创建连接池</h3><blockquote><p>Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用 Jedis 连接池代替 Jedis 的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们 tomcat 中的线程池，这些都是池化思想的体现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFacotry</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br><br>     <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//配置连接池</span><br>         <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>         poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>         poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>         poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>         poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>         <span class="hljs-comment">//创建连接池对象</span><br>         jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<br>                 <span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-keyword">return</span> jedisPool.getResource();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BeforeEach</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//建立连接</span><br>      <span class="hljs-comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span><br>      jedis = JedisConnectionFacotry.getJedis();<br>       <span class="hljs-comment">//选择库</span><br>      jedis.select(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 插入hash数据</span><br>      jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>      jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>      <span class="hljs-comment">// 获取</span><br>      Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>      System.out.println(map);<br>  &#125;<br> <span class="hljs-meta">@AfterEach</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>          jedis.close();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>测试成功！</p><h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多<strong>分布式服务</strong>。Redisson 的宗旨是<strong>促进使用者对 Redis 的关注分离</strong>（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="1-快速入门-1"><a href="#1-快速入门-1" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><h3 id="1-1-引入依赖-1"><a href="#1-1-引入依赖-1" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-配置-Redisson-客户端"><a href="#1-2-配置-Redisson-客户端" class="headerlink" title="1.2 配置 Redisson 客户端"></a>1.2 配置 Redisson 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-使用-Redission-的分布式锁"><a href="#1-3-使用-Redission-的分布式锁" class="headerlink" title="1.3 使用 Redission 的分布式锁"></a>1.3 使用 Redission 的分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Redisson 有非常多的分布式服务：</p><p>具体的各个用法需要结合官网和你的具体业务实现。</p><h1 id="Java-客户端总结"><a href="#Java-客户端总结" class="headerlink" title="Java 客户端总结"></a>Java 客户端总结</h1><ul><li>如果<strong>使用了 Spring</strong>，并且没有过多的定制化要求，那么大可以<strong>选择 Spring Data Redis</strong></li><li>如果<strong>没有使用 Spring</strong>，只需要实现简单的业务，也 <strong>没有过高的性能要求</strong>，那么可以<strong>选择 Jedis</strong></li><li>如果<strong>没有使用 Spring</strong>，并且 <strong>追求高性能、高定制化</strong>，可以<strong>用 Lettuce</strong>，支持异步、连接池</li><li>如果项目是<strong>分布式架构</strong>，<strong>需要一些分布式服务</strong>（分布式锁，分布式集合等等），那么可以<strong>选择 Redisson</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-11.盛最多水的容器</title>
    <link href="/2024/12/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/12/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="/img/articles/28-1.png"> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：[1,8,6,2,5,4,8,3,7]<br>输出：49 <br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：height = [1,1]<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> current=Math.min(height[left],height[right])*(right-left);<br>            res=Math.max(res,current);<br>            <span class="hljs-keyword">if</span>(height[left]&lt;height[right])&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-283.移动零</title>
    <link href="/2024/12/21/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2024/12/21/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [0]<br>输出: [0]<br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast&lt;nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>                nums[slow]=nums[fast];<br>                  slow++;<br>            &#125;   <br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=slow;i&lt;nums.length;i++)&#123;<br>            nums[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis 基础实战</title>
    <link href="/2024/12/20/Redis-Redis%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    <url>/2024/12/20/Redis-Redis%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Redis-入门"><a href="#一-Redis-入门" class="headerlink" title="一.Redis 入门"></a>一.Redis 入门</h1><h1 id="1-初识-Redis"><a href="#1-初识-Redis" class="headerlink" title="1. 初识 Redis"></a>1. 初识 Redis</h1><p>Redis 是一种<strong>键值型</strong>的 <strong>NoSql</strong> 数据库。</p><blockquote><p><strong>键值型</strong>：是指 Redis 中存储的数据都是<strong>以 key、value 对的形式存储</strong>，而 value 的形式多种多样，可以是字符串、数值、甚至 json</p></blockquote><h2 id="1-1-认识-NoSQL"><a href="#1-1-认识-NoSQL" class="headerlink" title="1.1 认识 NoSQL"></a>1.1 认识 NoSQL</h2><h3 id="1-1-1-什么是-NoSQL"><a href="#1-1-1-什么是-NoSQL" class="headerlink" title="1.1.1 什么是 NoSQL"></a>1.1.1 什么是 NoSQL</h3><hr><ul><li>NoSQL 最常见的解释是”<code>non-relational</code>“， 很多人也说它是”***Not Only SQL***“</li><li>NoSQL 仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li><li>区别于关系数据库，它们不保证关系数据的 ACID 特性</li><li>NoSQL 是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li><li>常见的 NoSQL 数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code> 等</li></ul><h3 id="1-1-2-NoSQL-与-SQL-的差异"><a href="#1-1-2-NoSQL-与-SQL-的差异" class="headerlink" title="1.1.2 NoSQL 与 SQL 的差异"></a>1.1.2 NoSQL 与 SQL 的差异</h3><hr><p>| | SQL | NoSQL |<br>| ——– | ————— | ————————————— | ————————— |<br>| 数据结构 | 结构化 | 非结构化 |<br>| 数据关联 | 关联的 | 无关联的 |<br>| 查询方式 | SQL 查询 | 非 SQL |<br>| 事务特性 | ACID | BASE |<br>| 存储方式 | 磁盘 | 内存 |<br>| 扩展性 | 垂直 | 水平 |<br>| 使用场景 | 1）数据结构固定 | 1）数据结构不固定 |<br>| | | 2）相关业务对数据安全性、一致性要求较高 | 2）对一致性、安全性要求不高 |<br>| | | 3）对性能要求 |</p><h1 id="2-Redis-常见命令"><a href="#2-Redis-常见命令" class="headerlink" title="2.Redis 常见命令"></a>2.Redis 常见命令</h1><blockquote><p>我们可以通过 Redis 的中文文档：<a href="http://www.redis.cn/commands.html%EF%BC%8C%E6%9D%A5%E5%AD%A6%E4%B9%A0%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4%E3%80%82">http://www.redis.cn/commands.html，来学习各种命令。</a></p><p>也可以通过菜鸟教程官网来学习：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p></blockquote><h2 id="2-1-Redis-数据类型"><a href="#2-1-Redis-数据类型" class="headerlink" title="2.1 Redis 数据类型"></a>2.1 Redis 数据类型</h2><blockquote><p>Redis 是一种 key-value 数据库，一般 key 都是 String，value 的类型五花八门。</p></blockquote><h2 id="2-2-Redis-基本命令"><a href="#2-2-Redis-基本命令" class="headerlink" title="2.2 Redis 基本命令"></a>2.2 Redis 基本命令</h2><blockquote><p>通用指令是部分数据类型的，都可以使用的指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>KEYS</td><td>查看符合模板的所有 key</td></tr><tr><td>DEL</td><td>删除一个指定的 key</td></tr><tr><td>EXISTS</td><td>判断 key 是否存在</td></tr><tr><td>EXPIRE</td><td>给一个 key 设置有效期，有效期到期时该 key 会被自动删除</td></tr><tr><td>TTL</td><td>查看一个 KEY 的剩余有效期</td></tr></tbody></table><p><strong>通过 help [command] 可以查看一个命令的具体用法</strong></p><h2 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h2><p>字符串类型，Redis 中最简单的存储类型。</p><p>其 value 是字符串，但是根据字符串的格式不同，可以分为三类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作。</li><li>float：浮点类型，可以做自增、自减操作。</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过 512m.</p><h3 id="2-3-1-String-类型常用命令"><a href="#2-3-1-String-类型常用命令" class="headerlink" title="2.3.1 String 类型常用命令"></a>2.3.1 String 类型常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>添加或者修改已经存在的一个 String 类型的键值对</td></tr><tr><td>GET</td><td>根据 key 获取 String 类型的 value</td></tr><tr><td>MSET</td><td>批量添加多个 String 类型的键值对</td></tr><tr><td>MGET</td><td>根据多个 key 获取多个 String 类型的 value</td></tr><tr><td>INCR</td><td>让一个整型的 key 自增 1</td></tr><tr><td>INCRBY</td><td>让一个整型的 key 自增并指定步长，例如：incrby num 2 让 num 值自增 2</td></tr><tr><td>INCRBYFLOAT</td><td>让一个浮点类型的数字自增并指定步长</td></tr><tr><td><strong>SETNX</strong></td><td>添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行</td></tr><tr><td>SETEX</td><td>添加一个 String 类型的键值对，并且指定有效期</td></tr></tbody></table><h2 id="2-4-Hash-类型"><a href="#2-4-Hash-类型" class="headerlink" title="2.4 Hash 类型"></a>2.4 Hash 类型</h2><blockquote><p><strong>Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的</strong><code>**HashMap**</code><strong>结构。</strong></p></blockquote><ul><li><p><strong>Hash 结构可以将对象中的每个字段独立存储，可以针对单个字段做 CRUD</strong></p></li><li><p>Hash 的常见命令有：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改 hash 类型 key 的 field 的值</td></tr><tr><td>HGET key field</td><td>获取一个 hash 类型 key 的 field 的值</td></tr><tr><td>HMSET</td><td>hmset 和 hset 效果相同 ，4.0 之后 hmset 可以弃用了</td></tr><tr><td>HMGET</td><td>批量获取多个 hash 类型 key 的 field 的值</td></tr><tr><td>HGETALL</td><td>获取一个 hash 类型的 key 中的所有的 field 和 value</td></tr><tr><td>HKEYS</td><td>获取一个 hash 类型的 key 中的所有的 field</td></tr><tr><td>HVALS</td><td>获取一个 hash 类型的 key 中的所有的 value</td></tr><tr><td>HINCRBY</td><td>让一个 hash 类型 key 的字段值自增并指定步长</td></tr><tr><td>HSETNX</td><td>添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</td></tr></tbody></table></li></ul><h2 id="2-5-List-类型"><a href="#2-5-List-类型" class="headerlink" title="2.5 List 类型"></a>2.5 List 类型</h2><blockquote><p><strong>Redis 中的 List 类型与 Java 中的 LinkedList 类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p></blockquote><p><strong>特征也与</strong><code>**LinkedList**</code><strong>类似：</strong></p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p><blockquote><p><strong>List 的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH key  element …</td><td>向列表左侧插入一个或多个元素</td></tr><tr><td>LPOP key</td><td>移除并返回列表左侧的第一个元素，没有则返回 nil</td></tr><tr><td><strong>RPUSH key  element …</strong></td><td>向列表右侧插入一个或多个元素</td></tr><tr><td>RPOP key</td><td>移除并返回列表右侧的第一个元素</td></tr><tr><td>LRANGE key star end</td><td>返回一段角标范围内的所有元素</td></tr><tr><td>BLPOP 和 BRPOP</td><td>与 LPOP 和 RPOP 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</td></tr></tbody></table><h2 id="2-6-Set-类型"><a href="#2-6-Set-类型" class="headerlink" title="2.6 Set 类型"></a>2.6 Set 类型</h2><blockquote><p><strong>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap。因为也是一个 hash 表，因此具备与 HashSet 类似的特征</strong></p></blockquote><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><blockquote><p><strong>Set 的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member …</td><td>向 set 中添加一个或多个元素</td></tr><tr><td>SREM key member …</td><td>移除 set 中的指定元素</td></tr><tr><td>SCARD key</td><td>返回 set 中元素的个数</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于 set 中</td></tr><tr><td>SMEMBERS</td><td>获取 set 中的所有元素</td></tr><tr><td>SINTER key1 key2 …</td><td>求 key1 与 key2 的交集</td></tr><tr><td>SDIFF key1 key2 …</td><td>求 key1 与 key2 的差集</td></tr><tr><td>SUNION key1 key2 ..</td><td>求 key1 和 key2 的并集</td></tr></tbody></table><h2 id="2-7-SortedSet-zset-类型"><a href="#2-7-SortedSet-zset-类型" class="headerlink" title="2.7 SortedSet (zset) 类型"></a>2.7 SortedSet (zset) 类型</h2><blockquote><p><strong>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层数据结构却差别很大。SortedSet 中的每一个元素都带有一个 score 属性，可以基于 score 属性对元素排序，底层的实现是一个跳表（SkipList）加 hash 表。</strong></p></blockquote><p><strong>SortedSet 具备下列特性：</strong></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为 SortedSet 的可排序特性，经常被用来实现排行榜这样的功能。</p><blockquote><p><strong>SortedSet 的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>ZADD key score member</td><td>添加一个或多个元素到 sorted set ，如果已经存在则更新其 score 值</td></tr><tr><td>ZREM key member</td><td>删除 sorted set 中的一个指定元素</td></tr><tr><td>ZSCORE key member</td><td>获取 sorted set 中的指定元素的 score 值</td></tr><tr><td>ZRANK key member</td><td>获取 sorted set 中的指定元素的排名</td></tr><tr><td>ZCARD key</td><td>获取 sorted set 中的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>统计 score 值在给定范围内的所有元素的个数</td></tr><tr><td>ZINCRBY key increment member</td><td>让 sorted set 中的指定元素自增，步长为指定的 increment 值</td></tr><tr><td>ZRANGE key min max</td><td>按照 score 排序后，获取指定排名范围内的元素</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照 score 排序后，获取指定 score 范围内的元素</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的 Z 后面添加</strong><code>**REV**</code><strong>即可</strong></p><blockquote><p><strong>跳跃表</strong></p><p>从第 2 层开始，1 节点比 51 节点小，向后比较。</p><p>21 节点比 51 节点小，继续向后比较，后面就是 NULL 了，所以从 21 节点向下到第 1 层</p><p>在第 1 层，41 节点比 51 节点小，继续向后，61 节点比 51 节点大，所以从 41 向下</p><p>在第 0 层，51 节点为要查找的节点，节点被找到，共查找 4 次。</p><p>从此可以看出跳跃表比有序链表效率要高</p></blockquote><h1 id="3-Redis-客户端"><a href="#3-Redis-客户端" class="headerlink" title="3.Redis 客户端"></a>3.Redis 客户端</h1><h2 id="3-Java-客户端"><a href="#3-Java-客户端" class="headerlink" title="3.Java 客户端"></a>3.Java 客户端</h2><h3 id="3-1-Jedis-快速入门"><a href="#3-1-Jedis-快速入门" class="headerlink" title="3.1 Jedis 快速入门"></a>3.1 Jedis 快速入门</h3><hr><blockquote><p>该部分参考：<a href="https://www.oz6.cn/articles/58">https://www.oz6.cn/articles/58</a><br>Jedis 的官网地址： <a href="https://github.com/redis/jedis%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A">https://github.com/redis/jedis，我们先来个快速入门：</a></p></blockquote><ul><li><strong>新建一个 Maven 工程并引入以下依赖</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入Jedis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入单元测试依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>编写测试类并与 Redis 建立连接</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span> <span class="hljs-comment">//被该注解修饰的方法每次执行其他方法前自动执行</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1. 获取连接</span><br>    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.230.88&quot;</span>,<span class="hljs-number">6379</span>);<br>    <span class="hljs-comment">// 2. 设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;132537&quot;</span>);<br>    <span class="hljs-comment">// 3. 选择库（默认是下标为0的库）</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>编写一个操作数据的方法（这里以操作 String 类型为例）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.往redis中存放一条String类型的数据并获取返回结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;www.oz6.cn&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br><br>    <span class="hljs-comment">// 2.从redis中获取一条数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;url&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;url = &quot;</span> + url);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>最后不要忘记编写一个释放资源的方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span> <span class="hljs-comment">//被该注解修饰的方法会在每次执行其他方法后执行</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.释放资源</span><br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>)&#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Jedis-连接池"><a href="#3-2-Jedis-连接池" class="headerlink" title="3.2 Jedis 连接池"></a>3.2 Jedis 连接池</h3><hr><blockquote><p><strong>Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用 Jedis 连接池代替 Jedis 的直连方式</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">200</span>);<br>        <span class="hljs-comment">//创建连接池对象</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig,<span class="hljs-string">&quot;192.168.230.88&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;132537&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-SpringDataRedis-介绍"><a href="#3-3-SpringDataRedis-介绍" class="headerlink" title="3.3 SpringDataRedis 介绍"></a>3.3 SpringDataRedis 介绍</h3><hr><blockquote><p><strong>SpringData 是 Spring 中数据操作的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做</strong><code>**SpringDataRedis**</code></p><p><strong>官网地址</strong>：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p></blockquote><ul><li>提供了对不同 Redis 客户端的整合（<code>Lettuce</code> 和 <code>Jedis</code>）</li><li>提供了 <code>RedisTemplate</code> 统一 API 来操作 Redis</li><li>支持 Redis 的发布订阅模型</li><li>支持 Redis 哨兵和 Redis 集群</li><li>支持基于 Lettuce 的响应式编程</li><li>支持基于 JDK、JSON、字符串、Spring 对象的数据序列化及反序列化</li><li>支持基于 Redis 的 JDKCollection 实现</li></ul><blockquote><p><strong>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：</strong></p></blockquote><h3 id="3-4-SpringDataRedis-快速入门"><a href="#3-4-SpringDataRedis-快速入门" class="headerlink" title="3.4 SpringDataRedis 快速入门"></a>3.4 SpringDataRedis 快速入门</h3><hr><blockquote><p><code>**SpringBoot**</code><strong>已经提供了对</strong><code>**SpringDataRedis**</code><strong>的支持，使用非常简单</strong></p></blockquote><ul><li><strong>首先新建一个 Spring Boot 工程</strong></li><li><strong>然后引入连接池依赖</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--连接池依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>编写配置文件</strong><code>**application.yml**</code><strong>（连接池的配置在实际开发中是根据需求来的）</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.230</span><span class="hljs-number">.88</span> <span class="hljs-comment">#指定redis所在的host</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span> <span class="hljs-comment">#指定redis的端口</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">132537</span> <span class="hljs-comment">#设置redis密码</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大连接数</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大空闲数</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#最小空闲数</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span><br></code></pre></td></tr></table></figure><ul><li><strong>编写测试类执行测试方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;<br><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 1.通过RedisTemplate获取操作String类型的ValueOperations对象</span><br><span class="hljs-type">ValueOperations</span> <span class="hljs-variable">ops</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br><span class="hljs-comment">// 2.插入一条数据</span><br>ops.set(<span class="hljs-string">&quot;blogName&quot;</span>,<span class="hljs-string">&quot;Vz-Blog&quot;</span>);<br><br><span class="hljs-comment">// 3.获取数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">blogName</span> <span class="hljs-operator">=</span> (String) ops.get(<span class="hljs-string">&quot;blogName&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;blogName = &quot;</span> + blogName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-RedisSerializer-配置"><a href="#3-5-RedisSerializer-配置" class="headerlink" title="3.5 RedisSerializer 配置"></a>3.5 RedisSerializer 配置</h3><hr><blockquote><p><strong>RedisTemplate 可以接收任意 Object 作为值写入 Redis，只不过写入前会把 Object 序列化为字节形式，</strong><code>**默认是采用JDK序列化**</code>**</p></blockquote><p><strong>缺点：</strong></p><ul><li>可读性差</li><li>内存占用较大</li></ul><blockquote><p><strong>那么如何解决以上的问题呢？我们可以通过自定义 RedisTemplate 序列化的方式来解决。</strong></p></blockquote><ul><li><strong>编写一个配置类</strong><code>**RedisConfig**</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span>&#123;<br>        <span class="hljs-comment">// 1.创建RedisTemplate对象</span><br>        RedisTemplate&lt;String ,Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 2.设置连接工厂</span><br>        redisTemplate.setConnectionFactory(factory);<br><br>        <span class="hljs-comment">// 3.创建序列化对象</span><br>        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">genericJackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br><br>        <span class="hljs-comment">// 4.设置key和hashKey采用String的序列化方式</span><br>        redisTemplate.setKeySerializer(stringRedisSerializer);<br>        redisTemplate.setHashKeySerializer(stringRedisSerializer);<br><br>        <span class="hljs-comment">// 5.设置value和hashValue采用json的序列化方式</span><br>        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);<br>        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);<br><br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>此时我们已经将 RedisTemplate 的 key 设置为</strong><code>**String序列化**</code><strong>，value 设置为</strong><code>**Json序列化**</code><strong>的方式，再来执行方法测试</strong></li><li><strong>由于我们设置的 value 序列化方式是 Json 的，因此我们可以直接向 redis 中插入一个对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> &#123;<br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:100&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Vz&quot;</span>, <span class="hljs-number">21</span>));<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:100&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;User = &quot;</span> + user);<br>&#125;<br>尽管 Json 序列化可以满足我们的需求，但是依旧存在一些问题。<br>如上图所示，为了在反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来额外的内存开销。<br>那么我们如何解决这个问题呢？我们可以通过下文的 `StringRedisTemplate` 来解决这个问题。<br></code></pre></td></tr></table></figure><h3 id="3-6-StringRedisTemplate"><a href="#3-6-StringRedisTemplate" class="headerlink" title="3.6 StringRedisTemplate"></a>3.6 StringRedisTemplate</h3><hr><blockquote><p><strong>为了节省内存空间，我们并不会使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><blockquote><p><strong>Spring 默认提供了一个 StringRedisTemplate 类，它的 key 和 value 的序列化方式默认就是 String 方式。省去了我们自定义 RedisTemplate 的过程</strong></p></blockquote><ul><li><strong>我们可以直接编写一个测试类使用 StringRedisTemplate 来执行以下方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTemplateTest</span> &#123;<br><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br><span class="hljs-comment">// 1.创建一个Json序列化对象</span><br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-comment">// 2.将要存入的对象通过Json序列化对象转换为字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">userJson1</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Vz&quot;</span>, <span class="hljs-number">21</span>));<br><span class="hljs-comment">// 3.通过StringRedisTemplate将数据存入redis</span><br>stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:100&quot;</span>,userJson1);<br><span class="hljs-comment">// 4.通过key取出value</span><br><span class="hljs-type">String</span> <span class="hljs-variable">userJson2</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:100&quot;</span>);<br><span class="hljs-comment">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> objectMapper.readValue(userJson2, User.class);<br><span class="hljs-comment">// 6.打印结果</span><br>System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>执行完毕回到 Redis 的图形化客户端查看结果</strong></li></ul><hr><blockquote><p>RedisTemplate 的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p></blockquote><p>方案一：</p><ol><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用 StringRedisTemplate</li><li>写入 Redis 时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ol><h1 id="二-Redis-实战"><a href="#二-Redis-实战" class="headerlink" title="二.Redis 实战"></a>二.Redis 实战</h1><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h1><h2 id="1-1-为什么用缓存"><a href="#1-1-为什么用缓存" class="headerlink" title="1.1 为什么用缓存"></a>1.1 为什么用缓存</h2><p><strong>速度快，好用</strong></p><p>缓存数据存储于代码中，而代码运行在内存中，<strong>内存的读写性能远高于磁盘</strong> , 缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><h2 id="1-2-缓存模型与思路"><a href="#1-2-缓存模型与思路" class="headerlink" title="1.2 缓存模型与思路"></a>1.2 缓存模型与思路</h2><p>标准的操作方式就是<strong>查询数据库之前先查询缓存</strong>，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入 redis</p><h2 id="1-3-缓存更新策略"><a href="#1-3-缓存更新策略" class="headerlink" title="1.3 缓存更新策略"></a>1.3 缓存更新策略</h2><p>缓存更新是 redis 为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向 redis 插入太多数据，此时就可能会导致缓存中的数据过多，所以 redis 会对部分数据进行更新，或者把他叫为淘汰更合适。</p><ul><li><strong>内存淘汰</strong>：当 redis 内存达到我们设置的阈值（max-memery）时，自动触发淘汰机制。</li><li><strong>超时剔除</strong>：给数据添加 TTL 时间，到时间自动剔除。</li><li><strong>主动更新</strong>：我们可以手动调用方法把缓存删掉，<strong>通常用于解决缓存和数据库不一致问题</strong></li></ul><h3 id="1-3-1-缓存与数据库数据不一致解决方案及选择"><a href="#1-3-1-缓存与数据库数据不一致解决方案及选择" class="headerlink" title="1.3.1 缓存与数据库数据不一致解决方案及选择"></a>1.3.1 缓存与数据库数据不一致解决方案及选择</h3><p><strong>缓存中的数据是来自于数据库</strong>的，但是<strong>数据库的数据是会改变</strong>的，如果<strong>数据库数据改变，缓存的数据没有改变</strong>，就会<strong>导致一致性问题</strong>，就会导致用户使用的是过时的数据，影响用户体验，有如下三种解决方案：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cache Aside Pattern ✔</td><td>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为<strong>双写方案</strong></td></tr><tr><td>Read&#x2F;Write Through Pattern</td><td>由系统本身完成，数据库与缓存的问题交由系统本身去处理</td></tr><tr><td>Write Behind Caching Pattern</td><td>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</td></tr></tbody></table><p>这里综合考虑我们选择<strong>方案一！</strong>✔</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以<strong>把缓存删除，等待再次查询时，将缓存中的数据加载出来</strong></p><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存 ✔</li></ul></li><li>如何保证缓存与数据库的操作的同时成功或失败？<ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用 TCC 等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是<strong>先操作数据库，再删除缓存</strong>，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程 1 先来，他先把缓存删了，此时线程 2 过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程 1 再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存 ✔</li></ul></li></ul><h2 id="1-4-缓存穿透"><a href="#1-4-缓存穿透" class="headerlink" title="1.4 缓存穿透"></a>1.4 缓存穿透</h2><p>缓存穿透 ：缓存穿透是指客户端请求的<strong>数据在缓存中和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>解决方案：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余 key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能（布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突）</li></ul></li></ul></li></ul><p><strong>小总结：</strong></p><p><strong>缓存穿透产生的原因是什么？</strong></p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p><strong>缓存穿透的解决方案有哪些？</strong></p><ul><li>缓存 null 值</li><li>布隆过滤</li><li>增强 id 的复杂度，避免被猜测 id 规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li><li>进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li><li>设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</li></ul><h2 id="1-5-缓存击穿"><a href="#1-5-缓存击穿" class="headerlink" title="1.5 缓存击穿"></a>1.5 缓存击穿</h2><p>缓存击穿问题也叫<strong>热点 Key 问题</strong>，就是<strong>一个</strong>被高并发访问并且缓存重建业务较复杂的 <strong>key 突然失效了</strong>，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li><strong>预先设置热门数据：</strong>把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长</li><li><strong>互斥锁</strong></li><li><strong>逻辑过期</strong></li></ul><p>逻辑分析：当多个线程过来查询缓存，发现都没有命中，于是乎都去查数据库，然后数据库就压力山大，直接爆炸。</p><h3 id="1-5-1-互斥锁解决缓存击穿"><a href="#1-5-1-互斥锁解决缓存击穿" class="headerlink" title="1.5.1 互斥锁解决缓存击穿"></a>1.5.1 互斥锁解决缓存击穿</h3><p>可以利用锁来防止多个线程同时去查询数据库，写缓存，<strong>只有拿到互斥锁的线程才能去查询数据库写缓存操作</strong>，其他线程拿不到互斥锁就休眠重试，等缓存中写入了之后，自然就能拿到数据。</p><p>加锁会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用 tryLock 方法 + double check 来解决这样的问题。</p><p>这里的互斥锁<strong>通过 setnx 的特性可以实现</strong>，setnx 只有在不存在数据时才能添加，有数据时添加失败。</p><h3 id="1-5-2-逻辑过期解决缓存击穿"><a href="#1-5-2-逻辑过期解决缓存击穿" class="headerlink" title="1.5.2 逻辑过期解决缓存击穿"></a>1.5.2 逻辑过期解决缓存击穿</h3><p>之所以会发生缓存击穿，是因为我们设置的 key 有过期时间，那么我们可以不给 key 设置过期时间啊，那这就有人会问，这不是会一直占用内存吗？，所以我们可以采用逻辑过期时间，<strong>把过期时间写入 value 中</strong>，用代码逻辑来判断该 key 是否过期。</p><p>这种方案巧妙在于，<strong>异步的构建缓存</strong>，缺点在于在构建完缓存之前，返回的都是脏数据。</p><h3 id="1-5-3-两种方案的对比"><a href="#1-5-3-两种方案的对比" class="headerlink" title="1.5.3 两种方案的对比"></a>1.5.3 两种方案的对比</h3><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h2 id="1-6-缓存雪崩"><a href="#1-6-缓存雪崩" class="headerlink" title="1.6 缓存雪崩"></a>1.6 缓存雪崩</h2><p>缓存雪崩是指在同一时段<strong>大量的缓存 key 同时失效</strong>或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的 Key 的 TTL 添加随机值</li><li>利用 Redis 集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）</li></ul><h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h1><h2 id="2-1-基本原理和实现方式对比"><a href="#2-1-基本原理和实现方式对比" class="headerlink" title="2.1 基本原理和实现方式对比"></a>2.1 基本原理和实现方式对比</h2><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且互斥的锁。</p><p>分布式锁必须满足的条件：</p><ul><li>可见性：<strong>多个线程都能看到相同的结果，</strong>注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li><strong>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</strong></li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h2 id="2-2-Redis-实现分布式锁"><a href="#2-2-Redis-实现分布式锁" class="headerlink" title="2.2 Redis 实现分布式锁"></a>2.2 Redis 实现分布式锁</h2><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li>获取锁：<ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回 true，失败返回 false</li></ul></li><li>释放锁：<ul><li>手动释放（del key）</li><li><strong>超时释放：获取锁时添加一个超时时间</strong></li></ul></li></ul><h3 id="2-2-1-核心思路"><a href="#2-2-1-核心思路" class="headerlink" title="2.2.1 核心思路"></a>2.2.1 核心思路</h3><p>利用 setnx 的特性：只有当 key 不存在时才可以设置成功，来实现分布式锁的互斥性，释放锁即把这个 key 删除即可。</p><h3 id="2-2-2-实现分布式锁版本一"><a href="#2-2-2-实现分布式锁版本一" class="headerlink" title="2.2.2 实现分布式锁版本一"></a>2.2.2 实现分布式锁版本一</h3><p>Ilock 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类 <strong>SimpleRedisLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX=<span class="hljs-string">&quot;lock:&quot;</span><br><span class="hljs-comment">//获取锁逻辑</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId()<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-comment">//释放锁逻辑</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;    <br>     <span class="hljs-comment">//通过del删除锁    </span><br>     stringRedisTemplate.delete(KEY_PREFIX + name);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-实现分布式锁版本二"><a href="#2-2-3-实现分布式锁版本二" class="headerlink" title="2.2.3 实现分布式锁版本二"></a>2.2.3 实现分布式锁版本二</h3><p>版本一面临的问题：因为<strong>线程可能阻塞导致锁超时自动释放</strong>，在释放锁时有可能<strong>释放的是别人的锁</strong></p><p>解决方案：在释放锁的时候先判断该锁是不是自己的锁，是自己的锁才释放，不是自己的锁不释放。</p><p>核心逻辑：在存入锁时，<strong>放入自己线程的标识（UUID）</strong>，在删除锁时，<strong>判断当前这把锁的标识是不是自己存入的</strong>，如果是，则进行删除，如果不是，则不进行删除。</p><p>具体代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在value上拼接UUID作为唯一标识</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-comment">//加锁逻辑</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>   <span class="hljs-comment">// 获取线程标示</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>   <span class="hljs-comment">// 获取锁</span><br>   <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>   <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-comment">//释放锁逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标示是否一致</span><br>    <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有关代码实操说明：</strong></p><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的 value 值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="2-2-4-实现分布式锁版本三"><a href="#2-2-4-实现分布式锁版本三" class="headerlink" title="2.2.4 实现分布式锁版本三"></a>2.2.4 实现分布式锁版本三</h3><p>考虑更加极端的情况：在删除锁的时候，已经判断成功唯一标识一致准备释放锁，在这之间进行了阻塞（JVM Full GC），那么仍然会导致误删的情况。</p><p>解决方案：让<strong>判断标志和释放锁两个动作具有原子性</strong>，保证一起进行中间不能停。</p><p>利用 lua 脚本来解决多条命令的原子性问题：这里不做讨论，我不会</p><p><strong>unlock.lua</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">lua<br>-- 比较线程标示与锁中的标示是否一致<br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) ==  ARGV[<span class="hljs-number">1</span>]) then<br>    -- 释放锁 del key<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br>end<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用lua脚本</span><br>    stringRedisTemplate.execute(<br>            UNLOCK_SCRIPT,<br>            Collections.singletonList(KEY_PREFIX + name),<br>            ID_PREFIX + Thread.currentThread().getId());<br>&#125;<br><span class="hljs-comment">//经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-小总结"><a href="#2-2-5-小总结" class="headerlink" title="2.2.5 小总结"></a>2.2.5 小总结</h3><p>基于 Redis 的分布式锁实现思路：</p><ul><li>利用 set nx ex 获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用 set nx 满足互斥性</li><li>利用 set ex 保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用 Redis 集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>我们一路走来，利用<strong>添加过期时间，防止死锁问题的发生</strong>，但是有了过期时间之后，可能<strong>出现误删别人锁的问题</strong>，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是<strong>删之前判断一下当前这把锁是否是属于自己的</strong>，但是现在还有<strong>原子性问题</strong>，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后<strong>通过 lua 表达式来解决这个问题</strong></p><p>但是目前还剩下一个问题，锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个 30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来 10 块的，是不是后边的问题都不会发生了，那么<strong>续期问题</strong>怎么解决呢，可以依赖于我们接下来要学习 redission 啦</p><h2 id="2-3-Redission"><a href="#2-3-Redission" class="headerlink" title="2.3 Redission"></a>2.3 Redission</h2><p><a href="https://dogbin.vip/coderbin/3e609eef.html#">Redission 的 github</a><br><a href="https://redisson.org/">Redisson 官网</a></p><h3 id="2-3-1-setnx-实现的分布式锁的问题"><a href="#2-3-1-setnx-实现的分布式锁的问题" class="headerlink" title="2.3.1 setnx 实现的分布式锁的问题"></a>2.3.1 setnx 实现的分布式锁的问题</h3><ul><li><strong>重入问题</strong>：重入问题是指 <strong>获得锁的线程可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于<strong>防止死锁</strong>，比如 HashTable 这样的代码中，他的方法都是使用 synchronized 修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的 synchronized 和 Lock 锁都是可重入的。</li><li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：<strong>当线程在获得锁失败后，他应该能再次尝试获得锁。</strong></li><li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了 lua 表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li><li><strong>主从一致性：</strong> 如果 Redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li></ul><h3 id="2-3-2-Redission-是什么"><a href="#2-3-2-Redission-是什么" class="headerlink" title="2.3.2 Redission 是什么"></a>2.3.2 Redission 是什么</h3><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h3 id="2-3-3-Redission-可重入锁原理"><a href="#2-3-3-Redission-可重入锁原理" class="headerlink" title="2.3.3 Redission 可重入锁原理"></a>2.3.3 Redission 可重入锁原理</h3><p>就是将原本 string 类型的 value 转换成了 hash 类型，hash 对应的 field 是线程名，value 则是一个计数器，<strong>当前线程每获取一次锁，则 value 加一，删除锁 value 减一</strong>，若 value 等于零则 del 锁。利用 lua 脚本实现。</p><h3 id="2-3-4-Redission-锁重试和-WatchDog-机制"><a href="#2-3-4-Redission-锁重试和-WatchDog-机制" class="headerlink" title="2.3.4 Redission 锁重试和 WatchDog 机制"></a>2.3.4 Redission 锁重试和 WatchDog 机制</h3><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=67&vd_source=665476c062292b64fa2949e9c935b109">实战篇 - 20. 分布式锁 - Redisson 的锁重试和 WatchDog 机制哔哩哔哩 bilibili</a></p><h3 id="2-3-5-Redission-锁的-MutiLock-原理"><a href="#2-3-5-Redission-锁的-MutiLock-原理" class="headerlink" title="2.3.5 Redission 锁的 MutiLock 原理"></a>2.3.5 Redission 锁的 MutiLock 原理</h3><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=68&vd_source=665476c062292b64fa2949e9c935b109">实战篇 - 21. 分布式锁 - Redisson 的 multiLock 原理哔哩哔哩 bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-1.两数之和</title>
    <link href="/2024/12/20/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/12/20/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [3,3], target = 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    HashMap&lt;Integer,Integer&gt;valToIndex=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-type">int</span> need=target-nums[i];<br>        <span class="hljs-keyword">if</span>(valToIndex.containsKey(need))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;valToIndex.get(need),i&#125;;<br>    &#125;<br>    valToIndex.put(nums[i],i);<br>   &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP中HTTPS的区别是什么?</title>
    <link href="/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP%E4%B8%ADHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP%E4%B8%ADHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p> <img src="/img/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png"> </p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis 实现 Session 共享</title>
    <link href="/2024/12/18/Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
    <url>/2024/12/18/Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fsession/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h1><ul><li>session 是一种服务端的会话机制</li><li>session 属于域对象，作用范围是一次会话</li></ul><p>服务器为每个用户创建一个会话，存储用户的相关信息，以便多次请求能够定位到同一个上下文。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p><h1 id="Session-一致性问题"><a href="#Session-一致性问题" class="headerlink" title="Session 一致性问题"></a>Session 一致性问题</h1><p>当第一次请求来时，服务器端会接受到客户端请求，会创建一个 session，使用响应头返回 sessionid 给客户端。浏览器获取到 sessionid 后会保存到本地 cookie 中</p><p>当第二次请求来时，客户端会读取本地的 sessionid，存放在请求头中，服务端在请求头中获取对象的 sessionid 在本地 session 内存中查询</p><p>session 属于会话机制，当前会话结束时，session 就会被销毁，并且 web 程序会为每一次不同的会话创建不同的 session，所以在分布式场景下，即使是调用同一个方法执行同样的代码，但是他们的服务器不同，自然 web 程序不同，整个上下文对象也不同，理所当然 session 也是不同的。</p><h1 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>当 Web 服务器接收到 http 请求后，请求进入对应的 Filter 进行过滤，将原本需要由 web 服务器创建会话的过程转交给 Spring-Session 进行创建，本来创建的会话保存在 Web 服务器内存中，通过 Spring-Session 创建的会话信息可以保存在第三方的服务中，如：Redis，MySQL 等。Web 服务器之间通过连接第三方服务来共享数据，实现 Session 共享！</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>修改 application.yml 添加配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">yourpassword</span> <span class="hljs-comment"># 如果设置了密码的话</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># Redis 数据库索引</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 连接超时时间（毫秒）</span><br>  <span class="hljs-attr">session:</span><br>    <span class="hljs-attr">store-type:</span> <span class="hljs-string">redis</span> <span class="hljs-comment"># 默认是 none，表示存储在单台服务器，redis 表示从 redis 读写 session</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus的使用</title>
    <link href="/2024/12/10/MyBatis-Plus%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/12/10/MyBatis-Plus%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus的使用"><a href="#MyBatis-Plus的使用" class="headerlink" title="MyBatis-Plus的使用"></a>MyBatis-Plus的使用</h1><p>数据库基本设计完毕，创建完数据库后就需要让后端连接数据库。在这里用<code>MyBatis-Plus</code>的代码生成器能快速生成<code>entity</code>,<code>mapper</code>,<code>service</code>等文件。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="第一步，添加依赖"><a href="#第一步，添加依赖" class="headerlink" title="第一步，添加依赖"></a>第一步，添加依赖</h3><p>在<code>pom.xml</code>文件中的<code>dependencies</code>里添加如下几行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我用的是最新的版本，如有问题请去<a href="https://baomidou.com/">官网</a>查看是否有更新。其中<code>freemarker</code>是我要使用的模版引擎。</p><h3 id="第二步-后端连接数据库"><a href="#第二步-后端连接数据库" class="headerlink" title="第二步 后端连接数据库"></a>第二步 后端连接数据库</h3><p>在<code>application.properties</code>下写明你要连接的数据库的详细信息，我用的是<code>mysql5.7</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">properties<br>spring.datasource.<span class="hljs-attribute">driver-class-name</span>=com.mysql.cj.jdbc.Driver<br>spring.datasource.<span class="hljs-attribute">url</span>=jdbc:mysql://localhost:3306/&quot;yourDatabaseName&quot;<br>spring.datasource.<span class="hljs-attribute">username</span>=<span class="hljs-string">&quot;yourSqlUsername(maybe root)&quot;</span><br>spring.datasource.<span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;yourSqlPassword&quot;</span><br>mybatis-plus.<span class="hljs-attribute">mapper-locations</span>=classpath:xml/*.xml<br>mybatis-plus.configuration.<span class="hljs-attribute">log-impl</span>=org.apache.ibatis.logging.stdout.StdOutImpl<br></code></pre></td></tr></table></figure><p>请将双引号的地方换上你自己要使用的。其中最后一句话是为了之后在终端打印出代码执行的sql语句。</p><h3 id="第三步-编写代码生成器代码"><a href="#第三步-编写代码生成器代码" class="headerlink" title="第三步 编写代码生成器代码"></a>第三步 编写代码生成器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.horsen.myproject;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;<br><br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeGenerator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tables</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;users,roles,xxx,xxx&quot;</span>;<br>        FastAutoGenerator.create(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/yourDatabaseName&quot;</span>,<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>)<br>                .globalConfig(builder -&gt; builder<br>                        .author(<span class="hljs-string">&quot;horsen&quot;</span>)<br>                        .outputDir(Paths.get(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>))+<span class="hljs-string">&quot;/src/main/java&quot;</span>)<br>                        .commentDate(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)<br>                )<br>                .packageConfig(builder -&gt; builder<br>                        .parent(<span class="hljs-string">&quot;com.airomance.easytravelroute&quot;</span>)<br>                        .entity(<span class="hljs-string">&quot;entity&quot;</span>)<br>                        .mapper(<span class="hljs-string">&quot;mapper&quot;</span>)<br>                        .service(<span class="hljs-string">&quot;service&quot;</span>)<br>                        .serviceImpl(<span class="hljs-string">&quot;service.impl&quot;</span>)<br>                        .xml(<span class="hljs-string">&quot;mapper.xml&quot;</span>)<br>                )<br>                .strategyConfig(builder -&gt; builder<br>                        .addInclude(tables.split(<span class="hljs-string">&quot;,&quot;</span>))<br>                        .entityBuilder()<br>                        .enableLombok()<br>                        .enableFileOverride()<br>                        .controllerBuilder()<br>                        .enableRestStyle()<br>                )<br>                .templateEngine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FreemarkerTemplateEngine</span>())<br>                .execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请将数据库涉及的数据库名称，用户名，密码换成自己的。还有包名。</p><h3 id="第四步-运行代码生成器-也可以直接用MyBatis-X插件生成"><a href="#第四步-运行代码生成器-也可以直接用MyBatis-X插件生成" class="headerlink" title="第四步 运行代码生成器(也可以直接用MyBatis-X插件生成)"></a>第四步 运行代码生成器(也可以直接用MyBatis-X插件生成)</h3><p>运行代码后应该会自动创建出<code>entity</code>,<code>mapper</code>,<code>service</code>，<code>controller</code>层等文件。这时需要把mapper文件夹下的xml文件夹移动到项目的<code>resources</code>文件夹下，这样方便配置也是一般的使用习惯。</p><p>注意，这里xml必须移动，原因在第二步已经设置了xml文件夹的路径，就是这句配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mybatis-<span class="hljs-keyword">plus</span>.mapper-locations=<span class="hljs-keyword">classpath</span>:xml<span class="hljs-comment">/*.xml</span><br></code></pre></td></tr></table></figure><h3 id="第五步-设置mapper路径"><a href="#第五步-设置mapper路径" class="headerlink" title="第五步 设置mapper路径"></a>第五步 设置mapper路径</h3><p>我们需要将mapper文件夹的路径告诉Spring boot，在启动项目的<code>application</code>文件下添加一个注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@MapperScan(<span class="hljs-string">&quot;com.horsen.myproject.mapper&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>添加后这个文件代码应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.horsen.myproject;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.horsen.myproject.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(Application.class, args);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此应该能够正常运行项目，然后进行接口的详细编写了。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器JDK安装和环境变量配置</title>
    <link href="/2024/12/07/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-JDK%E5%AE%89%E8%A3%85/"/>
    <url>/2024/12/07/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-JDK%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>1.安装JDK</strong>：</p><ul><li><p>对于CentOS，使用如下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo yum install java-1.8.0-openjdk-devel<br></code></pre></td></tr></table></figure></li><li><p>这将安装OpenJDK 8，包括<code>javac</code>编译器。</p></li></ul><p><strong>2.配置环境变量</strong>：</p><ul><li><p>安装完成后，需要配置JAVA_HOME环境变量,可以通过查找java命令的路径来确定JDK的安装位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo update-alternatives --config java<br></code></pre></td></tr></table></figure></li></ul><p>​      如下图示例：</p><p><img src="/img/articles/13.png"> </p><ul><li><p>使用文本编辑器打开<code>.bashrc</code>文件，例如使用<code>vi</code>（按i开启编辑，Esc+:wq保存+Enter退出）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vi ~/.bashrc<br></code></pre></td></tr></table></figure></li></ul><p>​       添加以下行到文件中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.412.b08-1.el7_9.x86_64<br>export PATH=$PATH:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>​      如下图示例：</p><p><img src="/img/articles/14.png"> </p><p>​     使更改生效，运行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">source ~/.bashrc<br></code></pre></td></tr></table></figure><p><strong>3.验证环境变量</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">echo $JAVA_HOME<br>echo $PATH<br></code></pre></td></tr></table></figure><p><strong>4.测试<code>javac</code>命令</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">javac -version<br></code></pre></td></tr></table></figure><p><strong>配置成功如下图</strong>：</p><p><img src="/img/articles/15.png"> </p><p>另外，再补充一部分以下是MySQL 8版本创建用户（赋予所有访问权限）的方法（刷新权限是flush privileges）</p><p><img src="/img/articles/16.png"> </p><p>面板也可相应创建</p>]]></content>
    
    
    <categories>
      
      <category>网站部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UML课设</title>
    <link href="/2024/11/17/UML%E8%AF%BE%E8%AE%BE/"/>
    <url>/2024/11/17/UML%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>课题：</p><p>利用面向对象思维与Python语言，设计一个仿真系统<br>1.设计思路汇报<br>2.编程实现</p><p>系统名称：投币式饮料自助售卖机系统</p><p><strong>Python代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> messagebox, simpledialog<br><br><span class="hljs-comment"># 用户基类，包含共有属性和方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    total_time_spent = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录所有用户的总耗时时间</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-comment"># 初始化用户的名字</span><br>        <span class="hljs-variable language_">self</span>.name = name<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time_spent</span>(<span class="hljs-params">cls, time_spent</span>):<br>        <span class="hljs-comment"># 类方法，用于累加操作的耗时</span><br>        cls.total_time_spent += time_spent  <span class="hljs-comment"># 增加耗时时间</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作耗时：<span class="hljs-subst">&#123;time_spent&#125;</span>秒，累计耗时：<span class="hljs-subst">&#123;cls.total_time_spent&#125;</span>秒。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">browse_drinks</span>(<span class="hljs-params">self, vending_machine, time_spent=<span class="hljs-number">20</span></span>):<br>        <span class="hljs-comment"># 用户浏览饮料的方法</span><br>        vending_machine.browse_drinks()  <span class="hljs-comment"># 调用售卖机的浏览饮料方法</span><br>        User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加浏览饮料的耗时</span><br><br><span class="hljs-comment"># 顾客类，继承自用户类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, customer_id</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)  <span class="hljs-comment"># 调用父类的构造方法初始化名字</span><br>        <span class="hljs-variable language_">self</span>.customer_id = customer_id  <span class="hljs-comment"># 初始化顾客ID</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">browse_drinks</span>(<span class="hljs-params">self, vending_machine</span>):<br>        <span class="hljs-built_in">super</span>().browse_drinks(vending_machine)  <span class="hljs-comment"># 调用父类的浏览饮料方法</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_drink</span>(<span class="hljs-params">self, drink_name, coin_value, vending_machine, time_spent=<span class="hljs-number">5</span></span>):<br>        <span class="hljs-comment">#顾客购买饮料的方法</span><br>        <span class="hljs-keyword">if</span> drink_name <span class="hljs-keyword">in</span> vending_machine.drinks:  <span class="hljs-comment"># 检查饮料是否存在</span><br>            drink = vending_machine.drinks[drink_name]<br>            <span class="hljs-keyword">if</span> drink.quantity &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 检查库存</span><br>                <span class="hljs-keyword">if</span> coin_value &gt;= drink.price:  <span class="hljs-comment"># 检查支付是否足够</span><br>                    change = coin_value - drink.price<br>                    <span class="hljs-keyword">if</span> change == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> vending_machine.calculate_change(change):  <span class="hljs-comment"># 检查是否可以找零</span><br>                        drink.quantity -= <span class="hljs-number">1</span>  <span class="hljs-comment"># 减少库存</span><br>                        vending_machine.save_drinks()  <span class="hljs-comment"># 保存饮料信息</span><br>                        vending_machine.save_transaction(coin_value)  <span class="hljs-comment"># 保存交易信息</span><br>                        User.add_time_spent(time_spent)  <span class="hljs-comment"># 记录耗时</span><br>                        <span class="hljs-keyword">if</span> change &gt; <span class="hljs-number">0</span>:<br>                            vending_machine.distribute_change(change)  <span class="hljs-comment"># 发放找零</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>, change  <span class="hljs-comment"># 返回成功和找零金额</span><br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 返回成功和0找零</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无法找零，请尝试其他面额的硬币。&quot;</span>)<br>                        User.add_time_spent(time_spent)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;资金不足，请增加硬币数量。&quot;</span>)<br>                    User.add_time_spent(time_spent)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;饮料缺货。&quot;</span>)<br>                User.add_time_spent(time_spent)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到饮料。&quot;</span>)<br>            User.add_time_spent(time_spent)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 管理员类，继承自用户类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Admin</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, admin_id, password</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)  <span class="hljs-comment"># 调用父类构造方法初始化名字</span><br>        <span class="hljs-variable language_">self</span>.admin_id = admin_id  <span class="hljs-comment"># 初始化管理员ID</span><br>        <span class="hljs-variable language_">self</span>.password = password  <span class="hljs-comment"># 初始化管理员密码</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, admin_id, password, time_spent=<span class="hljs-number">3</span></span>):<br>        <span class="hljs-comment"># 管理员登录</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.admin_id == <span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.password == <span class="hljs-string">&quot;admin&quot;</span>:  <span class="hljs-comment"># 验证管理员凭证</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;管理员登录成功。&quot;</span>)<br>            User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加登录时间</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;管理员凭证无效。&quot;</span>)<br>            User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replenish_drink</span>(<span class="hljs-params">self, drink_name, quantity, price, vending_machine, time_spent=<span class="hljs-number">3</span></span>):<br>        <span class="hljs-comment"># 管理员补充饮料</span><br>        vending_machine.add_drink(Drink(drink_name, quantity, price))  <span class="hljs-comment"># 将饮料添加到售卖机</span><br>        vending_machine.save_drinks()  <span class="hljs-comment"># 保存饮料信息</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;补充饮料库存成功。&quot;</span>)<br>        User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replenish_change</span>(<span class="hljs-params">self, coin_denomination, quantity, vending_machine, time_spent=<span class="hljs-number">2</span></span>):<br>        <span class="hljs-comment"># 管理员补充找零硬币</span><br>        <span class="hljs-keyword">if</span> coin_denomination <span class="hljs-keyword">in</span> vending_machine.coins:<br>            vending_machine.coins[coin_denomination].set_total(<br>                vending_machine.coins[coin_denomination].total + quantity)  <span class="hljs-comment"># 更新硬币数量</span><br>        <span class="hljs-keyword">else</span>:<br>            vending_machine.add_coin(Coin(coin_denomination))  <span class="hljs-comment"># 新增硬币面额</span><br>            vending_machine.coins[coin_denomination].set_total(quantity)  <span class="hljs-comment"># 设置数量</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;补充找零硬币成功。&quot;</span>)<br>        User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collect_coins</span>(<span class="hljs-params">self, vending_machine, time_spent=<span class="hljs-number">10</span></span>):<br>        <span class="hljs-comment"># 提取硬币</span><br>        collected_coins = vending_machine.collect_income_from_file()  <span class="hljs-comment"># 从文件收取硬币</span><br>        vending_machine.delete_income_file()  <span class="hljs-comment"># 删除收入文件</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已提取<span class="hljs-subst">&#123;collected_coins&#125;</span>元硬币。&quot;</span>)<br>        User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br>        <span class="hljs-keyword">return</span> collected_coins<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_drink_price</span>(<span class="hljs-params">self, drink_name, price, vending_machine, time_spent=<span class="hljs-number">2</span></span>):<br>        <span class="hljs-comment"># 设定饮料价格</span><br>        <span class="hljs-keyword">if</span> drink_name <span class="hljs-keyword">in</span> vending_machine.drinks:<br>            vending_machine.drinks[drink_name].set_price(price)  <span class="hljs-comment"># 设置饮料新价格</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;drink_name&#125;</span>的价格已设定为<span class="hljs-subst">&#123;price&#125;</span>&quot;</span>)<br>            User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 返回True表示成功设置价格</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到饮料，无法设置价格。&quot;</span>)<br>            User.add_time_spent(time_spent)  <span class="hljs-comment"># 累加时间</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 返回False表示未找到饮料</span><br><br><span class="hljs-comment"># 饮料类，描述饮料的属性和行为</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drink</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, quantity, price</span>):<br>        <span class="hljs-variable language_">self</span>.name = name  <span class="hljs-comment"># 饮料名称</span><br>        <span class="hljs-variable language_">self</span>.quantity = quantity  <span class="hljs-comment"># 饮料数量</span><br>        <span class="hljs-variable language_">self</span>.price = price  <span class="hljs-comment"># 饮料价格</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_price</span>(<span class="hljs-params">self, price</span>):<br>        <span class="hljs-comment"># 设定饮料价格</span><br>        <span class="hljs-variable language_">self</span>.price = price  <span class="hljs-comment"># 更新价格</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_name</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-comment"># 设定饮料名称</span><br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_quantity</span>(<span class="hljs-params">self, quantity</span>):<br>        <span class="hljs-comment"># 设定饮料数量</span><br>        <span class="hljs-variable language_">self</span>.quantity = quantity<br><br><span class="hljs-comment"># 硬币类，描述硬币的属性和行为</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, denomination</span>):<br>        <span class="hljs-variable language_">self</span>.denomination = denomination  <span class="hljs-comment"># 硬币面额</span><br>        <span class="hljs-variable language_">self</span>.total = <span class="hljs-number">0</span>  <span class="hljs-comment"># 硬币数量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_denomination</span>(<span class="hljs-params">self, denomination</span>):<br>        <span class="hljs-variable language_">self</span>.denomination = denomination  <span class="hljs-comment"># 设定硬币面额</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_total</span>(<span class="hljs-params">self, total</span>):<br>        <span class="hljs-variable language_">self</span>.total = total  <span class="hljs-comment"># 设定硬币数量</span><br><br><span class="hljs-comment"># 售卖机类，管理饮料、硬币以及收入</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VendingMachine</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.drinks = &#123;&#125;  <span class="hljs-comment"># 饮料库存</span><br>        <span class="hljs-variable language_">self</span>.coins = &#123;&#125;  <span class="hljs-comment"># 找零硬币数量</span><br>        <span class="hljs-variable language_">self</span>.total_income = <span class="hljs-number">0</span>  <span class="hljs-comment"># 总收入</span><br>        <span class="hljs-variable language_">self</span>.load_drinks()  <span class="hljs-comment"># 加载饮料信息，读取文件中的饮料信息</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_drink</span>(<span class="hljs-params">self, drink</span>):<br>        <span class="hljs-comment"># 添加饮料到库存</span><br>        <span class="hljs-variable language_">self</span>.drinks[drink.name] = drink<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_coin</span>(<span class="hljs-params">self, coin</span>):<br>        <span class="hljs-comment"># 添加找零硬币</span><br>        <span class="hljs-keyword">if</span> coin.denomination <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.coins:<br>            <span class="hljs-variable language_">self</span>.coins[coin.denomination].total += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.coins[coin.denomination] = coin<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">browse_drinks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 显示售卖机饮料中的饮料列表</span><br>        drink_list = <span class="hljs-string">&quot;\n&quot;</span>.join([<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>: 库存<span class="hljs-subst">&#123;drink.quantity&#125;</span>，价格：<span class="hljs-subst">&#123;drink.price&#125;</span>&quot;</span><br>                                <span class="hljs-keyword">for</span> name, drink <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.drinks.items()])<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> drink_list:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目前售卖机没有饮料。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目前可购买的饮料列表：&quot;</span>)<br>            <span class="hljs-built_in">print</span>(drink_list)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_drinks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 将饮料信息保存到文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;drinks.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">for</span> name, drink <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.drinks.items():<br>                f.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>,<span class="hljs-subst">&#123;drink.quantity&#125;</span>,<span class="hljs-subst">&#123;drink.price&#125;</span>\n&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_drinks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 从文件加载饮料信息</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;drinks.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>                    name, quantity, price = line.strip().split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>                    <span class="hljs-variable language_">self</span>.add_drink(Drink(name, <span class="hljs-built_in">int</span>(quantity), <span class="hljs-built_in">float</span>(price)))<br>        <span class="hljs-keyword">except</span> FileNotFoundError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目前售卖机没有饮料。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_change</span>(<span class="hljs-params">self, change</span>):<br>        <span class="hljs-comment"># 计算找零</span><br>        sorted_denominations = <span class="hljs-built_in">sorted</span>(<span class="hljs-variable language_">self</span>.coins.keys(), reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 按硬币面额降序排列</span><br>        <span class="hljs-keyword">for</span> denomination <span class="hljs-keyword">in</span> sorted_denominations:<br>            coins_to_give = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">int</span>(change // denomination), <span class="hljs-variable language_">self</span>.coins[denomination].total)<br>            <span class="hljs-keyword">if</span> coins_to_give &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.coins[denomination].total -= coins_to_give<br>                change -= coins_to_give * denomination<br>            <span class="hljs-keyword">if</span> change == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distribute_change</span>(<span class="hljs-params">self, change</span>):<br>        <span class="hljs-comment"># 分发找零硬币</span><br>        sorted_denominations = <span class="hljs-built_in">sorted</span>(<span class="hljs-variable language_">self</span>.coins.keys(), reverse=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">for</span> denomination <span class="hljs-keyword">in</span> sorted_denominations:<br>            coins_to_give = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">int</span>(change // denomination), <span class="hljs-variable language_">self</span>.coins[denomination].total)<br>            <span class="hljs-keyword">if</span> coins_to_give &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.coins[denomination].total -= coins_to_give<br>                change -= coins_to_give * denomination<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发放面额 <span class="hljs-subst">&#123;denomination&#125;</span> 元的硬币 <span class="hljs-subst">&#123;coins_to_give&#125;</span> 枚&quot;</span>)<br>        <span class="hljs-keyword">return</span> change == <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_transaction</span>(<span class="hljs-params">self, coin_value</span>):<br>        <span class="hljs-comment"># 保存交易记录到文件</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;income.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;coin_value&#125;</span>\n&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.total_income += coin_value<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;写入文件时发生错误：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collect_income_from_file</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 从文件计算收入总和</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;income.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                income = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">float</span>(line.strip()) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f)<br>            <span class="hljs-keyword">return</span> income<br>        <span class="hljs-keyword">except</span> FileNotFoundError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未查询到收入。&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_income_file</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 删除收入文件</span><br>        <span class="hljs-keyword">try</span>:<br>            os.remove(<span class="hljs-string">&#x27;income.txt&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前将用户投入的所有硬币全部提取出来。&quot;</span>)<br>        <span class="hljs-keyword">except</span> FileNotFoundError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有硬币可提取。&quot;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;删除文件时发生错误：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 可视化界面部分</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUI</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, master, vending_machine, customer, admin</span>):<br>        <span class="hljs-comment"># 初始化图形界面的构造方法</span><br>        <span class="hljs-variable language_">self</span>.master = master<br>        <span class="hljs-variable language_">self</span>.master.title(<span class="hljs-string">&quot;投币式饮料自助售卖机系统&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.vending_machine = vending_machine<br>        <span class="hljs-variable language_">self</span>.customer = customer<br>        <span class="hljs-variable language_">self</span>.admin = admin<br><br>        <span class="hljs-comment"># 创建窗口顶部的标题标签</span><br>        title_label = tk.Label(master, text=<span class="hljs-string">&quot;投币式饮料自助售卖机系统&quot;</span>, font=(<span class="hljs-string">&quot;Arial&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;bold&quot;</span>))<br>        title_label.pack(pady=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 放置标题标签，并在垂直方向上添加外边距</span><br><br>        <span class="hljs-comment"># 创建操作按钮</span><br>        <span class="hljs-variable language_">self</span>.browse_button = tk.Button(master, text=<span class="hljs-string">&quot;浏览饮料&quot;</span>, command=<span class="hljs-variable language_">self</span>.browse_drinks)<br>        <span class="hljs-variable language_">self</span>.browse_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        <span class="hljs-variable language_">self</span>.buy_button = tk.Button(master, text=<span class="hljs-string">&quot;购买饮料&quot;</span>, command=<span class="hljs-variable language_">self</span>.buy_drink)<br>        <span class="hljs-variable language_">self</span>.buy_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        <span class="hljs-variable language_">self</span>.admin_button = tk.Button(master, text=<span class="hljs-string">&quot;管理员登录&quot;</span>, command=<span class="hljs-variable language_">self</span>.admin_login)<br>        <span class="hljs-variable language_">self</span>.admin_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        <span class="hljs-variable language_">self</span>.quit_button = tk.Button(master, text=<span class="hljs-string">&quot;退出&quot;</span>, command=master.quit)<br>        <span class="hljs-variable language_">self</span>.quit_button.pack(pady=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">browse_drinks</span>(<span class="hljs-params">self</span>):<br>        start_time = time.time()  <span class="hljs-comment"># 记录开始时间</span><br>        drink_list = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> name, drink <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.vending_machine.drinks.items():<br>            drink_list += <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>: 库存<span class="hljs-subst">&#123;drink.quantity&#125;</span>，价格：<span class="hljs-subst">&#123;drink.price&#125;</span>\n&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> drink_list:<br>            drink_list = <span class="hljs-string">&quot;目前售卖机没有饮料。&quot;</span><br><br>        messagebox.showinfo(<span class="hljs-string">&quot;浏览饮料&quot;</span>, drink_list)<br>        end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span><br>        elapsed_time = end_time - start_time<br>        elapsed_time = <span class="hljs-built_in">round</span>(elapsed_time)<br>        User.add_time_spent(elapsed_time)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_drink</span>(<span class="hljs-params">self</span>):<br>        drink_name = simpledialog.askstring(<span class="hljs-string">&quot;购买饮料&quot;</span>, <span class="hljs-string">&quot;请输入饮料名称：&quot;</span>)<br>        coin_value = simpledialog.askfloat(<span class="hljs-string">&quot;购买饮料&quot;</span>, <span class="hljs-string">&quot;请输入投入硬币的金额：&quot;</span>)<br><br>        success, change = <span class="hljs-variable language_">self</span>.customer.buy_drink(drink_name, coin_value, <span class="hljs-variable language_">self</span>.vending_machine)<br>        <span class="hljs-keyword">if</span> success:<br>            <span class="hljs-keyword">if</span> change &gt; <span class="hljs-number">0</span>:<br>                messagebox.showinfo(<span class="hljs-string">&quot;购买成功&quot;</span>, <span class="hljs-string">f&quot;购买成功！发放找零：<span class="hljs-subst">&#123;change&#125;</span>元。&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                messagebox.showinfo(<span class="hljs-string">&quot;购买成功&quot;</span>, <span class="hljs-string">&quot;购买成功！不需要找零。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showerror(<span class="hljs-string">&quot;购买失败&quot;</span>, <span class="hljs-string">&quot;购买失败，请检查饮料是否有货或硬币金额是否足够。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_login</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 管理员登录处理</span><br>        login_window = tk.Toplevel(<span class="hljs-variable language_">self</span>.master)<br>        login_window.title(<span class="hljs-string">&quot;管理员登录&quot;</span>)<br><br>        tk.Label(login_window, text=<span class="hljs-string">&quot;管理员ID:&quot;</span>).pack(pady=<span class="hljs-number">5</span>)<br>        admin_id = tk.Entry(login_window)<br>        admin_id.pack(pady=<span class="hljs-number">5</span>)<br><br>        tk.Label(login_window, text=<span class="hljs-string">&quot;管理员密码:&quot;</span>).pack(pady=<span class="hljs-number">5</span>)<br>        password = tk.Entry(login_window, show=<span class="hljs-string">&quot;*&quot;</span>)<br>        password.pack(pady=<span class="hljs-number">5</span>)<br><br>        login_button = tk.Button(login_window, text=<span class="hljs-string">&quot;登录&quot;</span>,<br>                                 command=<span class="hljs-keyword">lambda</span>: <span class="hljs-variable language_">self</span>.admin_actions(admin_id.get(), password.get()))<br>        login_button.pack(pady=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_actions</span>(<span class="hljs-params">self, admin_id, password</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.admin.login(admin_id, password):<br>            <span class="hljs-variable language_">self</span>.admin_menu()<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showerror(<span class="hljs-string">&quot;登录失败&quot;</span>, <span class="hljs-string">&quot;管理员凭证无效，请重试。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_menu</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 管理员操作菜单</span><br>        menu_window = tk.Toplevel(<span class="hljs-variable language_">self</span>.master)<br>        menu_window.title(<span class="hljs-string">&quot;管理员操作&quot;</span>)<br><br>        replenish_drinks_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;补充饮料&quot;</span>, command=<span class="hljs-variable language_">self</span>.replenish_drinks)<br>        replenish_drinks_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        batch_import_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;批量补充饮料&quot;</span>, command=<span class="hljs-variable language_">self</span>.batch_import_drinks)<br>        batch_import_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        replenish_change_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;补充找零硬币&quot;</span>, command=<span class="hljs-variable language_">self</span>.replenish_change)<br>        replenish_change_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        collect_coins_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;提取硬币&quot;</span>, command=<span class="hljs-variable language_">self</span>.collect_coins)<br>        collect_coins_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        set_price_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;设定饮料价格&quot;</span>, command=<span class="hljs-variable language_">self</span>.set_drink_price)<br>        set_price_button.pack(pady=<span class="hljs-number">10</span>)<br><br>        logout_button = tk.Button(menu_window, text=<span class="hljs-string">&quot;注销&quot;</span>, command=menu_window.destroy)<br>        logout_button.pack(pady=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replenish_drinks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 补充饮料的功能</span><br>        drink_name = simpledialog.askstring(<span class="hljs-string">&quot;补充饮料&quot;</span>, <span class="hljs-string">&quot;请输入饮料名称：&quot;</span>)<br>        <span class="hljs-keyword">if</span> drink_name:  <span class="hljs-comment"># 检查用户是否输入了饮料名称</span><br>            quantity = simpledialog.askinteger(<span class="hljs-string">&quot;补充饮料&quot;</span>, <span class="hljs-string">&quot;请输入补充数量：&quot;</span>)<br>            <span class="hljs-keyword">if</span> quantity <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 检查用户是否输入了数量</span><br>                price = simpledialog.askfloat(<span class="hljs-string">&quot;补充饮料&quot;</span>, <span class="hljs-string">&quot;请输入饮料价格：&quot;</span>)<br>                <span class="hljs-keyword">if</span> price <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 检查用户是否输入了价格</span><br>                    <span class="hljs-variable language_">self</span>.admin.replenish_drink(drink_name, quantity, price, <span class="hljs-variable language_">self</span>.vending_machine)<br>                    messagebox.showinfo(<span class="hljs-string">&quot;补充成功&quot;</span>, <span class="hljs-string">&quot;饮料库存补充成功！&quot;</span>)<br>                    <span class="hljs-variable language_">self</span>.vending_machine.save_drinks()  <span class="hljs-comment"># 保存饮料信息</span><br>                <span class="hljs-keyword">else</span>:<br>                    messagebox.showwarning(<span class="hljs-string">&quot;补充失败&quot;</span>, <span class="hljs-string">&quot;请输入有效的饮料价格。&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                messagebox.showwarning(<span class="hljs-string">&quot;补充失败&quot;</span>, <span class="hljs-string">&quot;请输入有效的补充数量。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showwarning(<span class="hljs-string">&quot;补充失败&quot;</span>, <span class="hljs-string">&quot;请输入饮料名称。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_import_drinks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 批量补充饮料的功能</span><br>        start_time = time.time()  <span class="hljs-comment"># 记录开始时间</span><br>        import_window = tk.Toplevel(<span class="hljs-variable language_">self</span>.master)<br>        import_window.title(<span class="hljs-string">&quot;批量补充饮料&quot;</span>)<br><br>        tk.Label(import_window, text=<span class="hljs-string">&quot;请输入饮料数据（格式：名称,数量,价格）：&quot;</span>).pack(pady=<span class="hljs-number">5</span>)<br>        text_area = tk.Text(import_window, height=<span class="hljs-number">10</span>, width=<span class="hljs-number">50</span>)<br>        text_area.pack(pady=<span class="hljs-number">5</span>)<br>        import_button = tk.Button(import_window, text=<span class="hljs-string">&quot;补充&quot;</span>, command=<span class="hljs-keyword">lambda</span>: <span class="hljs-variable language_">self</span>.import_drinks(text_area.get(<span class="hljs-string">&quot;1.0&quot;</span>, tk.END), start_time))<br>        import_button.pack(pady=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">import_drinks</span>(<span class="hljs-params">self, data, start_time</span>):<br>        <span class="hljs-comment"># 处理批量补充饮料数据</span><br>        lines = data.strip().split(<span class="hljs-string">&quot;\n&quot;</span>)<br>        success_count = <span class="hljs-number">0</span><br>        fail_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>            <span class="hljs-keyword">try</span>:<br>                name, quantity, price = line.split(<span class="hljs-string">&quot;,&quot;</span>)<br>                quantity = <span class="hljs-built_in">int</span>(quantity)<br>                price = <span class="hljs-built_in">float</span>(price)<br>                <span class="hljs-variable language_">self</span>.admin.replenish_drink(name, quantity, price, <span class="hljs-variable language_">self</span>.vending_machine)<br>                success_count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">except</span> ValueError:<br>                fail_count += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;格式错误或数据转换失败：<span class="hljs-subst">&#123;line&#125;</span>&quot;</span>)<br><br>        end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span><br>        elapsed_time = end_time - start_time<br>        elapsed_time = <span class="hljs-built_in">round</span>(elapsed_time)<br>        User.add_time_spent(elapsed_time)<br><br>        <span class="hljs-keyword">if</span> success_count &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.vending_machine.save_drinks()<br>            messagebox.showinfo(<span class="hljs-string">&quot;批量补充成功&quot;</span>, <span class="hljs-string">f&quot;成功导入<span class="hljs-subst">&#123;success_count&#125;</span>条数据。&quot;</span>)<br>        <span class="hljs-keyword">if</span> fail_count &gt; <span class="hljs-number">0</span>:<br>            messagebox.showwarning(<span class="hljs-string">&quot;批量补充失败&quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;fail_count&#125;</span>条数据格式错误或转换失败。请检查输入格式。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replenish_change</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 补充找零硬币的功能</span><br>        coin_denomination = simpledialog.askinteger(<span class="hljs-string">&quot;补充硬币&quot;</span>, <span class="hljs-string">&quot;请输入硬币面额：&quot;</span>)<br>        <span class="hljs-keyword">if</span> coin_denomination <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 检查用户是否输入了硬币面额</span><br>            quantity = simpledialog.askinteger(<span class="hljs-string">&quot;补充硬币&quot;</span>, <span class="hljs-string">&quot;请输入补充数量：&quot;</span>)<br>            <span class="hljs-keyword">if</span> quantity <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 检查用户是否输入了数量</span><br>                <span class="hljs-variable language_">self</span>.admin.replenish_change(coin_denomination, quantity, <span class="hljs-variable language_">self</span>.vending_machine)<br>                messagebox.showinfo(<span class="hljs-string">&quot;补充成功&quot;</span>, <span class="hljs-string">&quot;找零硬币补充成功！&quot;</span>)<br>                <span class="hljs-variable language_">self</span>.vending_machine.save_drinks()  <span class="hljs-comment"># 保存找零硬币信息</span><br>            <span class="hljs-keyword">else</span>:<br>                messagebox.showwarning(<span class="hljs-string">&quot;取消操作&quot;</span>, <span class="hljs-string">&quot;未输入数量，操作已取消。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showwarning(<span class="hljs-string">&quot;取消操作&quot;</span>, <span class="hljs-string">&quot;未输入硬币面额，操作已取消。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collect_coins</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 提取硬币的功能</span><br>        collected_coins = <span class="hljs-variable language_">self</span>.admin.collect_coins(<span class="hljs-variable language_">self</span>.vending_machine)<br>        <span class="hljs-keyword">if</span> collected_coins <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            message = <span class="hljs-string">f&quot;硬币提取成功！共提取<span class="hljs-subst">&#123;collected_coins&#125;</span>元硬币。&quot;</span><br>            messagebox.showinfo(<span class="hljs-string">&quot;提取成功&quot;</span>, message)<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showinfo(<span class="hljs-string">&quot;提取成功&quot;</span>, <span class="hljs-string">&quot;没有硬币可提取。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_drink_price</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 设置饮料价格的功能</span><br>        drink_name = simpledialog.askstring(<span class="hljs-string">&quot;设定价格&quot;</span>, <span class="hljs-string">&quot;请输入饮料名称：&quot;</span>)<br>        <span class="hljs-keyword">if</span> drink_name:  <span class="hljs-comment"># 检查用户是否输入了饮料名称</span><br>            price = simpledialog.askfloat(<span class="hljs-string">&quot;设定价格&quot;</span>, <span class="hljs-string">&quot;请输入新价格：&quot;</span>)<br>            <span class="hljs-keyword">if</span> price <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 检查用户是否输入了价格</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.admin.set_drink_price(drink_name, price, <span class="hljs-variable language_">self</span>.vending_machine):<br>                    messagebox.showwarning(<span class="hljs-string">&quot;设置失败&quot;</span>, <span class="hljs-string">&quot;未找到饮料，无法设置价格。&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                messagebox.showwarning(<span class="hljs-string">&quot;设置失败&quot;</span>, <span class="hljs-string">&quot;请输入有效的价格。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            messagebox.showwarning(<span class="hljs-string">&quot;设置失败&quot;</span>, <span class="hljs-string">&quot;请输入饮料名称。&quot;</span>)<br><span class="hljs-comment"># 主程序，创建应用并启动</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_vending_machine_gui</span>():<br>    <span class="hljs-comment"># 初始化各个对象</span><br>    vending_machine = VendingMachine()<br>    customer = Customer(<span class="hljs-string">&quot;用户&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>)<br>    admin = Admin(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)<br><br>    root = tk.Tk()<br>    root.geometry(<span class="hljs-string">&quot;600x400&quot;</span>)  <span class="hljs-comment"># 设置窗口大小</span><br>    app = GUI(root, vending_machine, customer, admin)<br><br>    <span class="hljs-comment"># 初始化饮料和找零硬币</span><br>    admin.replenish_drink(<span class="hljs-string">&quot;可乐&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3.0</span>, vending_machine, time_spent=<span class="hljs-number">3</span>)<br>    admin.replenish_drink(<span class="hljs-string">&quot;雪碧&quot;</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3.0</span>, vending_machine, time_spent=<span class="hljs-number">3</span>)<br>    admin.replenish_drink(<span class="hljs-string">&quot;矿泉水&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2.0</span>, vending_machine, time_spent=<span class="hljs-number">3</span>)<br>    admin.replenish_change(<span class="hljs-number">1.0</span>, <span class="hljs-number">1000</span>, vending_machine, time_spent=<span class="hljs-number">2</span>)<br><br>    root.mainloop()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run_vending_machine_gui()<br>       <span class="hljs-comment"># 投币式饮料自助售卖机系统程序说明：</span><br><span class="hljs-comment"># 1.程序运行之后会有一个可视化的界面弹窗用来进行交互</span><br><span class="hljs-comment"># 2.系统是基于时间的，每一个操作都设置了具体时间消耗，会在执行之后在控制台打印出来</span><br><span class="hljs-comment"># 3.程序开始运行后，会先进行补充饮料和找零硬币的初始化</span><br><span class="hljs-comment"># 4.管理员登录操作的账号是admin，密码是admin</span><br><span class="hljs-comment"># 5.顾客投入的硬币数据通过写入新建的文本文件(.txt)来存储</span><br><span class="hljs-comment"># 6.管理员补充的饮料相关数据通过写入新建的文本文件(.txt)来存储</span><br><span class="hljs-comment"># 7.管理员提取硬币操作提取的是顾客投入的硬币，不提取找零硬币</span><br><span class="hljs-comment"># 8.管理员能够对饮料数据进行批量补充</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面向对象分析与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战后端接入物联网API</title>
    <link href="/2024/11/16/%E7%89%A9%E8%81%94%E7%BD%91API%E6%8E%A5%E5%85%A5%E5%90%8E%E7%AB%AF/"/>
    <url>/2024/11/16/%E7%89%A9%E8%81%94%E7%BD%91API%E6%8E%A5%E5%85%A5%E5%90%8E%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>团队项目有一个业务要获取阿里云物联网平台上面的传感器数据，代码使用java，采用springboot框架，阿里云物联网平台上一个产品下的一个设备只能连接真实设备或者代码服务端，于是我采用数据流转的方式将数据流转到一个设备中，服务端订阅该设备的<strong>Topic</strong>。</p><p><strong>这里先讲讲我在接入真实设备并将数据信息上传到阿里云的云端平台设备，但是后端会被挤掉线的问题的解决方式:</strong></p><p><em>以下是相关记录</em></p><ol><li><p>解决了后端连接阿里云物联网平台掉线问题，能够收到真实设备所发的信息</p><p><img src="/img/articles/9.png"></p></li></ol><p>解决方式：</p><p>a.在阿里云物联网平台使用同一个产品密钥又再建立了一台新设备，将真实设备传到的阿里云端（之前建好设备）的消息再进行一次转发到新设备，使后端连接这台新备进行消息接收并且不会掉线。</p><p>  <img src="/img/articles/10.png"> </p><p>b.后端接收消息流程如下（采用MQTT协议,只允许一对一的连接，若有多个连接，会把先连接的下线掉）：</p><p>  <img src="/img/articles/11.png"> </p><h2 id="阿里云创建"><a href="#阿里云创建" class="headerlink" title="阿里云创建"></a>阿里云创建</h2><p>首先创建一个产品，用于测试使用，直接选择一个标准品类，品类有温度和湿度属性（实际使用需要按需求自定义产品），节点类型为了方便选的直连设备。</p><p>产品创建完成之后点击<strong>查看</strong>，点击<strong>功能定义</strong>模块，编辑草稿，添加刚才选择的标准产品的两个标准功能，也可以添加自定义功能看自己选择，这边只使用温度和湿度。</p><p>发布完成之后进入Topic 类列表的自定义Topic 部分</p><p>定义一个Topic类，便于后面通过该Topic流转到服务器端，操作权限为发布和订阅，命名为tento(按照自己需求命名)，点击确认就定义完成了。</p><p>之后为这个产品添加两个设备（一个真实设备，一个服务器设备（一个用来收真实设备的信息，一个用来将真实设备的信息转过来节接收）），实际使用可以创建多个真实设备，数据流转到一个服务器设备中就可以了，为了方便这边只创建两个设备测试。直接添加，DeviceName让他随机生成。</p><p>创建一个解析器（在云产品流转那里）</p><p>点击查看这个数据源，添加Topic，因为我要获取真实设备的数据，所以选择物模型数据上报的Topic，设备DeviceName选择刚才创建的真实设备，最后选择post。这样数据源就完成了</p><p>然后进入数据目的，点击关联数据目的</p><p>和刚才操作类似点击关联数据目的—-&gt;创建数据目的，产品选择我们一开始创建的产品，操作为发送到另一个Topic。</p><p>最后是解析器脚本，会有一个草稿，脚本中的writeIotTopic(1004），<strong>1004是自动生成的，自己的代码不要改这个</strong></p><p>改为</p><p>只更改了&#x2F;k1a8gKQzYMD&#x2F;ejP0IrtXk49UIMz7Wsn1&#x2F;user&#x2F;tento是刚才咱们自定义的Topic，k1a8gKQzYMD为产品的ProductKey，ejP0IrtXk49UIMz7Wsn1为服务端设备的DeviceName，点击发布就完成了这个解析器，解析器一定要点击启动才会生效。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>开两个设备模拟器</p><p>真实设备端</p><p>服务器端</p><p>服务器端订阅刚才自定义的Topic</p><p>点击订阅之后，右边日志会显示订阅的Topic <strong>(订阅这一步不能省)</strong></p><p>再回到真实设备的模拟器（<strong>服务器模拟器不要关</strong>，<strong>开两个网页</strong>），输入温度湿度数据之后，点击提交，模拟真实设备提交数据。</p><p>真实设备提交数据之后，刚才服务器设备的模拟器订阅了这个消息，就会收到消息。</p><p>消息中包括刚才真实设备上传的温度湿度，还包括真实设备的deviceName，这样如果多个真实设备上传数据，全部流转到服务器端，服务器端就是知道真实设备是哪一个，上传的数据是多少。</p>]]></content>
    
    
    <categories>
      
      <category>物联网API接入</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后端接入讯飞星火API</title>
    <link href="/2024/11/16/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A51/"/>
    <url>/2024/11/16/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A51/</url>
    
    <content type="html"><![CDATA[<p>如何引入？先看官方文档</p><p><a href="https://www.xfyun.cn/doc/spark/Web.html#_2-function-call%E8%AF%B4%E6%98%8E:~:text=%23-,3.%20%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B,-%E6%B3%A8%3A%20demo%E5%8F%AA%E6%98%AF">https://www.xfyun.cn/doc/spark/Web.html#_2-function-call%E8%AF%B4%E6%98%8E:~:text=%23-,3.%20%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B,-%E6%B3%A8%3A%20demo%E5%8F%AA%E6%98%AF</a></p><p>我建议引入其他大佬写好的 sdk ，GitHub 地址：<a href="https://github.com/briqt/xunfei-spark4j">https://github.com/briqt/xunfei-spark4j</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--修改version为最新稳定版--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.briqt<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xunfei-spark4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用的话，不使用硬编码，而是把相关信息写在配置文件里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">SparkClient sparkClient=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SparkClient</span>();<br><br><span class="hljs-comment">// 设置认证信息</span><br>sparkClient.appid=<span class="hljs-string">&quot;&quot;</span>;<br>sparkClient.apiKey=<span class="hljs-string">&quot;&quot;</span>;<br>sparkClient.apiSecret=<span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>config 文件，读取我们配置的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;xunfei.client&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XingHuoConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String appid;<br>    <span class="hljs-keyword">private</span> String apiSecret;<br>    <span class="hljs-keyword">private</span> String apiKey;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SparkClient <span class="hljs-title function_">sparkClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SparkClient</span> <span class="hljs-variable">sparkClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparkClient</span>();<br>        sparkClient.setApiKey(apiKey);<br>        sparkClient.setApiSecret(apiSecret);<br>        sparkClient.setAppid(appid);<br>        <span class="hljs-keyword">return</span> sparkClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果生成的内容不符合自己的预期，解决方法：给他一个符合标准的例子, 虽然有耗费 token 但是暂时没想到更好的方式</p><p>这个 PRECONDITION 是我在 service 调用之前手动拼接到 content 前面，没太深入了解是不是能提前指定预设😅</p><p>AI 服务类相关的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aiservice</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> SparkClient sparkClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ClientV4 clientV4;<br><br>    <span class="hljs-comment">// 稳定的随机数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">STABLE_TEMPERATURE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.05f</span>;<br><br>    <span class="hljs-comment">//预设角色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRECONDITION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你是一个$&#123;角色定义&#125;，接下来我会按照以下固定格式给你提供内容：\n&quot;</span> +。。。。 + <span class="hljs-string">&quot;下面是一个具体的例子的模板：&quot;</span>+;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 星火AI 对话</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMesToAIUseXingHuo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String content)</span> &#123;<br>        List&lt;SparkMessage&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        messages.add(SparkMessage.userContent(content));<br>        <span class="hljs-comment">// 构造请求</span><br>        <span class="hljs-type">SparkRequest</span> <span class="hljs-variable">sparkRequest</span> <span class="hljs-operator">=</span> SparkRequest.builder()<br>                <span class="hljs-comment">// 消息列表</span><br>                .messages(messages)<br>                <span class="hljs-comment">// 模型回答的tokens的最大长度,非必传,取值为[1,4096],默认为2048</span><br>                .maxTokens(<span class="hljs-number">2048</span>)<br>                <span class="hljs-comment">// 核采样阈值。用于决定结果随机性,取值越高随机性越强即相同的问题得到的不同答案的可能性越高 非必传,取值为[0,1],默认为0.5</span><br>                .temperature(<span class="hljs-number">0.2</span>)<br>                <span class="hljs-comment">// 指定请求版本，默认使用最新2.0版本</span><br>                .apiVersion(SparkApiVersion.V3_5)<br>                .build();<br>        <span class="hljs-comment">// 同步调用</span><br>        <span class="hljs-type">SparkSyncChatResponse</span> <span class="hljs-variable">chatResponse</span> <span class="hljs-operator">=</span> sparkClient.chatSync(sparkRequest);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">responseContent</span> <span class="hljs-operator">=</span> chatResponse.getContent();<br>        log.info(<span class="hljs-string">&quot;星火 AI 返回的结果 &#123;&#125;&quot;</span>, responseContent);<br>        <span class="hljs-keyword">return</span> responseContent;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI大模型接入</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多环境概念理解</title>
    <link href="/2024/11/16/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%A4%9A%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/11/16/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%A4%9A%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h3 id="一：多环境概念："><a href="#一：多环境概念：" class="headerlink" title="一：多环境概念："></a>一：多环境概念：</h3><p>是指根据项目的不同阶段和需求，将项目部署在不同的环境中，以确保各环境之间相互独立且互不影响。多环境设计的主要目的是为了在不同的开发、测试和部署阶段中，确保项目的稳定性和可靠性。</p><h4 id="省流：根据实际需要，对项目阶段进行部署，相互独立且互相不影响。"><a href="#省流：根据实际需要，对项目阶段进行部署，相互独立且互相不影响。" class="headerlink" title="省流：根据实际需要，对项目阶段进行部署，相互独立且互相不影响。"></a>省流：<strong>根据实际需要，对项目阶段进行部署，相互独立且互相不影响。</strong></h4><h5 id="多环境的分类："><a href="#多环境的分类：" class="headerlink" title="多环境的分类："></a>多环境的分类：</h5><ol><li>本地环境(自己的电脑）localhost（熟悉的localhost）</li><li>开发环境：公司连同一台机器，方便开发</li><li>测试环境：性能测试&#x2F;功能测试&#x2F;系统集成测试</li><li>预发布环境（体验服）：用正式服的数据再进行测试</li><li>正式环境（线上，公开访问的项目）</li><li>沙箱环境：目的就是为了做实验（做完就销毁）</li></ol><h3 id="二：前端配置多环境："><a href="#二：前端配置多环境：" class="headerlink" title="二：前端配置多环境："></a>二：前端配置多环境：</h3><h5 id="1：请求地址："><a href="#1：请求地址：" class="headerlink" title="1：请求地址："></a>1：请求地址：</h5><ul><li>开发环境：localhost:8000</li><li>线上环境：域名或者公网ip</li></ul><p><strong>2：启动方式：</strong>（本人习惯使用npm）<br>npm run start </p><p>通常用于启动开发服务器或者应用程序的开发模式。这个命令一般会启动一个开发服务器，监听文件变化并自动重新加载应用，以方便开发人员在开发过程中进行实时调试。这个命令通常用于开发阶段，不会对代码进行优化和压缩，以便开发人员能够方便地调试和查看代码变化。</p><p>npm run build </p><p>通常用于构建生产环境下的部署包。这个命令会对项目代码进行优化、压缩和打包，以减小文件大小并提高运行效率。通常会生成用于部署的静态文件，准备好被部署到生产服务器上。这个命令一般在项目准备发布时执行，以确保发布的代码是经过优化和压缩的<br><strong>3：项目的配置：</strong></p><p> 不同的项目（框架）都有不同的配置文件，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。</p><p>以vue项目举例，<code>NODE_ENV</code>环境变量通常用于指示当前的环境，是否为开发环境或生产环境。在开发环境中，通常会设置<code>NODE_ENV</code>为<code>development</code>，而在生产环境中设置为<code>production</code>。</p><p>build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数</p><p>所以我们的思路是什么呢</p><p>我们可以在前端的拦截器上加一个判断条件，如果NODE_ENV是等于这个production的，我们就转到我们想要转的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const isDev = process.env.NODE_ENV === &#x27;development&#x27;;<br>const Service = axios.create(&#123;<br>    baseURL: isDev ? &#x27;http://localhost:8089/&#x27; : &#x27;http://公网ip或者域名&#x27;,<br>    withCredentials: true,<br>&#125;);<br>Service.defaults.withCredentials = true;<br></code></pre></td></tr></table></figure><p>一般上线的话，需要运行<strong>build 进行打包构建，然后生成一个dist文件</strong></p><p>随后，可以在项目终端使用 serve 工具启动（npm i -g serve，先安装），浏览打包好了的文件 </p><h3 id="三：后端配置多环境："><a href="#三：后端配置多环境：" class="headerlink" title="三：后端配置多环境："></a>三：后端配置多环境：</h3><h5 id="后端和前端一样都需要配置文件："><a href="#后端和前端一样都需要配置文件：" class="headerlink" title="后端和前端一样都需要配置文件："></a>后端和前端一样都需要配置文件：</h5><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件(如application-prod.yml作为线上配置 )</p><h5 id="然后我们运行maven中的package，对项目进行打包"><a href="#然后我们运行maven中的package，对项目进行打包" class="headerlink" title="然后我们运行maven中的package，对项目进行打包"></a>然后我们运行maven中的package，对项目进行打包</h5><p>另外，如果单元测试不重要，我们就可以点击跳过测试模式这个按钮。</p><p> 打包完之后，我们在这个打包出来的文件夹（target）的终端中输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -jar .\backend-<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>那一行代码的意思就是往里传了一个环境参数，运行后就会切换到线上配置</p>]]></content>
    
    
    <categories>
      
      <category>网站部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于IDEA的mysql驱动文件下载失败的解决办法（来自以前的csdn）</title>
    <link href="/2024/11/12/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%981/"/>
    <url>/2024/11/12/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%981/</url>
    
    <content type="html"><![CDATA[<p>第一步，在官网上找到如图</p><p> <img src="/img/articles/1.png"> </p><p> 第二步 </p><p><img src="/img/articles/2.png"></p><p> 第三步</p><p>将下载好的驱动文件先解压然后再复制到安装IDEA的文件目录下面</p><p><img src="/img/articles/3.png"></p><p>最后，再回去IDEA点击驱动的下载</p><p>成功如图</p><p><img src="/img/articles/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>配置各类环境所遇问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2024/09/30/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/09/30/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程基础"><a href="#Java并发编程基础" class="headerlink" title="Java并发编程基础"></a>Java并发编程基础</h1><h2 id="Synchronized的作用范围"><a href="#Synchronized的作用范围" class="headerlink" title="Synchronized的作用范围"></a>Synchronized的作用范围</h2><ul><li><strong>修饰实例方法</strong>：对当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li><li><strong>修饰静态方法</strong>：对当前类加锁，会作用于类的所有对象实例。因为静态成员不属于任何一个实例对象，是类成员。</li><li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li></ul><p><strong>总结</strong>：<br><code>synchronized</code>可以锁住类，也可以锁住类的某个对象，二者相互独立，不冲突。</p><h2 id="深入理解volatile关键字"><a href="#深入理解volatile关键字" class="headerlink" title="深入理解volatile关键字"></a>深入理解volatile关键字</h2><h3 id="知识预备：可见性和原子性"><a href="#知识预备：可见性和原子性" class="headerlink" title="知识预备：可见性和原子性"></a>知识预备：可见性和原子性</h3><ul><li><strong>原子性</strong>：一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用共享数据。</li><li><strong>可见性</strong>：必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。</li></ul><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><ul><li><strong>保证可见性</strong>：一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li><strong>不能保证原子性</strong>：不能保证<code>volatile</code>变量复合操作的原子性，因为同一变量可以有多个线程进行修改。</li></ul><h3 id="示例代码：体现volatile的可见性"><a href="#示例代码：体现volatile的可见性" class="headerlink" title="示例代码：体现volatile的可见性"></a>示例代码：体现volatile的可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileVisibilityExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程A修改flag的值为true</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            flag = <span class="hljs-literal">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;Thread A sets flag to true&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 线程B检查flag的值，如果为true则输出消息</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!flag) &#123;<br>                <span class="hljs-comment">// 循环等待，直到flag的值变为true</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread B detects flag is now true&quot;</span>);<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VolatileVisibilityExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileVisibilityExample</span>();<br>        example.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>指令重排序可以优化代码的执行顺序，但不能改变变量的最终结果。例如，对一个变量的两次写操作的相对位置不能改变，否则会导致最终结果发生改变。</p><h3 id="单例模式双重检查失效问题"><a href="#单例模式双重检查失效问题" class="headerlink" title="单例模式双重检查失效问题"></a>单例模式双重检查失效问题</h3><p><code>new</code>关键字创建对象不是原子操作，创建一个对象会经历以下步骤：</p><ol><li>在堆内存开辟内存空间。</li><li>调用构造方法，初始化对象。</li><li>引用变量指向堆内存空间。</li></ol><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。经过指令重排序之后，创建对象的执行顺序可能为<code>1 -&gt; 2 -&gt; 3</code>或者<code>1 -&gt; 3 -&gt; 2</code>。因此，当某个线程在乱序运行<code>1 -&gt; 3 -&gt; 2</code>指令的时候，引用变量指向堆内存空间，这个对象不为<code>null</code>，但是没有初始化，其他线程有可能这个时候进入了<code>getInstance</code>的第一个<code>if (instance == null)</code>判断，导致错误地使用了没有初始化的非<code>null</code>实例，这就是著名的DCL失效问题。</p><p>当我们在引用变量上添加<code>volatile</code>关键字以后，会通过在创建对象指令的前后添加内存屏障来禁止指令重排序，从而避免这个问题，而且对<code>volatile</code>修饰的变量的修改对其他任何线程都是可见的。</p><h2 id="ThreadLocal学习"><a href="#ThreadLocal学习" class="headerlink" title="ThreadLocal学习"></a>ThreadLocal学习</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><p><code>ThreadLocal</code>是一个线程的“本地变量”，这种变量在多线程环境下访问（通过<code>get</code>和<code>set</code>方法访问）时能够保证各个线程的变量相对独立于其他线程内的变量，不同线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>通过当前线程对象<code>thread</code>获取该<code>thread</code>所维护的<code>ThreadLocalMap</code>，如果<code>ThreadLocalMap</code>不为<code>null</code>，则以<code>ThreadLocal</code>实例为<code>key</code>，值为<code>value</code>的键值对存入<code>ThreadLocalMap</code>；若<code>ThreadLocalMap</code>为<code>null</code>的话，就新建<code>ThreadLocalMap</code>，然后再以<code>ThreadLocal</code>为键，值为<code>value</code>的键值对存入即可。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>通过当前线程<code>thread</code>实例获取到它所维护的<code>ThreadLocalMap</code>，然后以当前<code>ThreadLocal</code>实例为<code>key</code>获取该<code>map</code>中的键值对（<code>Entry</code>）。如果<code>Entry</code>不为<code>null</code>则返回<code>Entry</code>的<code>value</code>。如果获取<code>ThreadLocalMap</code>为<code>null</code>或者<code>Entry</code>为<code>null</code>的话，就以当前<code>ThreadLocal</code>为<code>Key</code>，<code>value</code>为<code>null</code>存入<code>map</code>后，并返回<code>null</code>。</p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-comment">// 创建ThreadLocal对象，做成public static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Task是线程类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>            <span class="hljs-type">Pig</span> <span class="hljs-variable">pig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>            <span class="hljs-comment">// 给threadLocal1对象放入set dog</span><br>            System.out.println(<span class="hljs-string">&quot;Task 放入了 dog= &quot;</span> + dog);<br>            threadLocal1.set(dog);<br>            threadLocal2.set(pig); <span class="hljs-comment">// 这个数据就会被threadLocal2关联，并且都被当前Thread管理</span><br>            System.out.println(<span class="hljs-string">&quot;Task 在run 方法中 线程=&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">T1Service</span>().update();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>()).start(); <span class="hljs-comment">// 主线程启动一个新的线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal的内部实现"><a href="#ThreadLocal的内部实现" class="headerlink" title="ThreadLocal的内部实现"></a>ThreadLocal的内部实现</h3><p>创建<code>static</code>修饰的<code>ThreadLocal</code>对象于运行线程的类中，线程<code>Thread t</code>维护一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread对象的实例数据</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>它是一个<code>HashMap</code>，里面的<code>Entry</code>的结构为<code>(key, value) —&gt; (线程id，值)</code>。</p><p><strong>一个线程所在的类可以有多个<code>ThreadLocal</code>对象，每个<code>threadLocal</code>对象都会在线程维护的<code>threadLocals</code>中以键的形式存在。</strong></p><h2 id="ReentrantLock和AQS"><a href="#ReentrantLock和AQS" class="headerlink" title="ReentrantLock和AQS"></a>ReentrantLock和AQS</h2><h3 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h3><p>AQS中使用的是CLH变体队列。</p><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><ul><li><strong>CLH队列</strong>：是单向链表实现的队列。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱节点释放了锁就结束自旋。</li><li><strong>特性</strong>：<ul><li>CLH队列是一个单向链表，保持FIFO先进先出的队列特性。</li><li>通过<code>tail</code>尾节点（原子引用）来构建队列，总是指向最后一个节点。</li><li>未获得锁节点会进行自旋，而不是切换线程状态。</li><li>并发高时性能较差，因为未获得锁节点不断轮询前驱节点的状态来查看是否获得锁。</li></ul></li></ul><h3 id="AQS中的CLH变体队列"><a href="#AQS中的CLH变体队列" class="headerlink" title="AQS中的CLH变体队列"></a>AQS中的CLH变体队列</h3><ul><li><strong>AQS队列</strong>：是一个双向链表，也是FIFO先进先出的特性。</li><li><strong>特性</strong>：<ul><li>通过<code>head</code>和<code>tail</code>头尾两个节点来组成队列结构，通过<code>volatile</code>修饰保证可见性。</li><li><code>head</code>指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程。</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于CLH队列性能较好。</li></ul></li></ul><h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h3><p>当线程获取锁失败时，<code>ReentrantLock</code>首先再<code>tryAcquire()</code>一下，<code>tryAcquire</code>失败，则AQS会将当前线程以及等待状态等信息构造成为一个节点（<code>Node</code>对象）并将其加入AQS中，同时会阻塞当前线程。</p><h3 id="条件队列与阻塞队列"><a href="#条件队列与阻塞队列" class="headerlink" title="条件队列与阻塞队列"></a>条件队列与阻塞队列</h3><ul><li><strong>条件队列和阻塞队列的节点</strong>：都是<code>Node</code>的实例，因为条件队列的节点是需要转移到阻塞队列中去的。</li><li><strong>Condition的实现</strong>：<ul><li>每个<code>ReentrantLock</code>实例可以通过多次调用<code>newCondition()</code>产生多个<code>Condition</code>实例。</li><li>每个<code>condition</code>有一个关联的条件队列，如线程调用<code>condition1.await()</code>方法即可将当前线程包装成<code>Node</code>后加入到条件队列中，然后阻塞在这里。</li><li>调用<code>condition1.signal()</code>触发一次唤醒，此时唤醒的是队头，会将<code>condition1</code>对应的条件队列的<code>firstWaiter</code>（队头）移到阻塞队列的队尾，等待获取锁，获取锁后<code>await</code>方法才能返回，继续往下执行。</li></ul></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // 核心线程数</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize, // 最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime, // 空闲线程存活时间</span><br><span class="hljs-params">                          TimeUnit unit, // 存活时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 任务的阻塞队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory, // 新线程的产生方式</span><br><span class="hljs-params">                          RejectedExecutionHandler handler // 拒绝策略</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><h3 id="向线程池中添加任务"><a href="#向线程池中添加任务" class="headerlink" title="向线程池中添加任务"></a>向线程池中添加任务</h3><p>通过<code>ThreadPoolExecutor.execute(Runnable command)</code>方法，即可向线程池内添加一个任务。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li>**<code>shutdown()</code>**：执行后停止接受新任务，但会把队列的任务执行完毕。</li><li>**<code>shutdownNow()</code>**：执行后停止接受新任务，但会中断所有的任务（不管是否正在执行中），将线程池状态变为<code>STOP</code>状态。</li></ul><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ol><li><strong>AbortPolicy</strong>：拒绝任务时抛出<code>RejectedExecutionException</code>异常。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务，不通知。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中存活时间最长的任务，为新任务腾出空间。</li><li><strong>CallerRunsPolicy</strong>：将任务交由提交任务的线程执行。</li></ol><h2 id="读书笔记整理"><a href="#读书笔记整理" class="headerlink" title="读书笔记整理"></a>读书笔记整理</h2><h3 id="Java线程实现-创建方式"><a href="#Java线程实现-创建方式" class="headerlink" title="Java线程实现&#x2F;创建方式"></a>Java线程实现&#x2F;创建方式</h3><ol><li><strong>实现<code>Runnable</code>接口中的<code>run</code>方法</strong>：然后把实现<code>run</code>方法的对象实例传入<code>Thread</code>类中。</li><li><strong>继承<code>Thread</code>类</strong>：继承<code>Thread</code>类，重写<code>run</code>方法。</li><li><strong>线程池创建线程</strong>：线程池创建线程源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    DefaultThreadFactory() &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>            Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>            poolNumber.getAndIncrement() +<br>            <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r,<br>                    namePrefix + threadNumber.getAndIncrement(),<br>        <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>有返回值的<code>Callable</code>创建线程</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务，并用Future提交返回结果</span><br>Future&lt;Integer&gt; future = service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableTask</span>());<br></code></pre></td></tr></table></figure></li></ol><h3 id="为什么实现Runnable接口比继承Thread类实现线程要好？"><a href="#为什么实现Runnable接口比继承Thread类实现线程要好？" class="headerlink" title="为什么实现Runnable接口比继承Thread类实现线程要好？"></a>为什么实现<code>Runnable</code>接口比继承<code>Thread</code>类实现线程要好？</h3><ul><li><strong>代码架构</strong>：实现了<code>Runnable</code>与<code>Thread</code>类的解耦，<code>Thread</code>类负责线程启动和属性设置等内容，权责分明。</li><li><strong>性能</strong>：使用实现<code>Runnable</code>接口的方式，可以将任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</li><li><strong>类的拓展</strong>：Java语言不支持双继承，如果我们的类一旦继承了<code>Thread</code>类，那么它后续就没有办法再继承其他的类，不方便类的拓展。</li></ul><h3 id="如何正确停止线程"><a href="#如何正确停止线程" class="headerlink" title="如何正确停止线程"></a>如何正确停止线程</h3><ul><li><p><strong>使用<code>interrupt</code>停止线程</strong>：</p><ul><li><code>void interrupt()</code>：向线程发送中断请求，线程的中断状态将被设置为<code>true</code>。</li><li><code>static boolean interrupted()</code>：测试当前线程是否被中断——静态方法——会将当前线程的中断状态重置为<code>false</code>。</li><li><code>boolean isInterrupted()</code>：测试当前线程是否被中断——不会改变线程的中断状态。</li><li>示例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count++);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThread</span>());<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">5</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>sleep</code>期间能否感受到中断？</strong></p><ul><li>如果线程处于<code>sleep</code>、<code>wait</code>等阻塞状态，且被中断，那么线程是可以感受到中断信号的，并且会抛出<code>InterruptedException</code>异常，同时清除中断信号，将中断标记位设置成<code>false</code>。</li><li>如果我们想让线程的调用者察觉到这种情况的发生，可以通过以下两种方式：<ol><li>**<code>catch InterruptedException</code>异常后，将中断状态再次设置为<code>true</code>**（不推荐，耦合度高）。</li><li><strong><code>throw InterruptedException</code>异常即可，调用者再<code>try-catch</code>即可捕获异常</strong>。</li></ol></li></ul></li><li><p><strong>为什么用<code>volatile</code>标记位的停止方法是错误的？</strong></p><ul><li><code>volatile</code>这种方法在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断，所以<code>volatile</code>是不够全面的停止线程的方法。</li><li>线程被长时间阻塞：因为你是根据<code>volatile</code>变量的值的情况去判断是否停止进程，但是如果你在哪阻塞了，即使那个变量改变了也没用，<code>volatile</code>标记位在程序运行到对该变量进行判断的语句时才对线程产生影响。</li></ul></li></ul><h3 id="线程是如何在6种状态之间转换的？"><a href="#线程是如何在6种状态之间转换的？" class="headerlink" title="线程是如何在6种状态之间转换的？"></a>线程是如何在6种状态之间转换的？</h3><p>线程可以有以下6种状态：</p><ul><li>New（新建）</li><li>Runnable（可运行）</li><li>Blocked（阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（终止）</li></ul><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>表示线程被创建但尚未启动的状态。当我们用<code>new Thread()</code>新建一个线程时，如果线程没有开始运行<code>start()</code>方法，所以也没有开始执行<code>run()</code>方法里面的代码，那么此时它的状态就是<code>New</code>。而一旦线程调用了<code>start()</code>，它的状态就会从<code>New</code>变成<code>Runnable</code>。</p><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Java中的<code>Runnable</code>状态对应操作系统线程状态中的两种状态，分别是<code>Running</code>和<code>Ready</code>，也就是说，Java中处于<code>Runnable</code>状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配CPU资源。</p><h4 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h4><p>从<code>Runnable</code>状态进入<code>Blocked</code>状态只有一种可能，就是进入<code>synchronized</code>保护的代码时没有抢到<code>monitor</code>锁，无论是进入<code>synchronized</code>代码块，还是<code>synchronized</code>方法，都是一样。</p><h4 id="Waiting"><a href="#Waiting" class="headerlink" title="Waiting"></a>Waiting</h4><p>线程进入<code>Waiting</code>状态有以下三种可能性：</p><ul><li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法。</li><li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法。</li><li><code>LockSupport.park()</code>方法。</li></ul><h4 id="Timed-Waiting"><a href="#Timed-Waiting" class="headerlink" title="Timed Waiting"></a>Timed Waiting</h4><p>线程进入<code>Timed Waiting</code>状态的情况：</p><ul><li>设置了时间参数的<code>Thread.sleep(long millis)</code>方法。</li><li>设置了时间参数的<code>Object.wait(long timeout)</code>方法。</li><li>设置了时间参数的<code>Thread.join(long millis)</code>方法。</li><li>设置了时间参数的<code>LockSupport.parkNanos(long nanos)</code>方法和<code>LockSupport.parkUntil(long deadline)</code>方法。</li></ul><h4 id="Terminated"><a href="#Terminated" class="headerlink" title="Terminated"></a>Terminated</h4><ul><li><code>run()</code>方法执行完毕，线程正常退出。</li><li>出现一个没有捕获的异常，终止了<code>run()</code>方法，最终导致意外终止。</li></ul><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><ul><li><strong>Blocked状态进入Runnable状态</strong>：要求线程获取<code>monitor</code>锁。</li><li><strong>Waiting状态流转到其他状态</strong>：<ul><li>如果执行了<code>LockSupport.unpark()</code>，或者<code>join</code>的线程运行结束，或者被中断时，可以进入<code>Runnable</code>状态。</li><li>如果其他线程调用<code>notify()</code>或<code>notifyAll()</code>来唤醒它，它会直接进入<code>Blocked</code>状态，因为唤醒<code>Waiting</code>线程的线程如果调用<code>notify()</code>或<code>notifyAll()</code>，要求必须首先持有该<code>monitor</code>锁，所以处于<code>Waiting</code>状态的线程被唤醒时拿不到该锁，就会进入<code>Blocked</code>状态，直到执行了<code>notify()</code>&#x2F;<code>notifyAll()</code>的唤醒它的线程执行完毕并释放<code>monitor</code>锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从<code>Blocked</code>状态回到<code>Runnable</code>状态。</li></ul></li><li><strong>Timed Waiting状态同理</strong>：只不过是在规定时间范围内与<code>Waiting</code>相同。</li></ul><h3 id="wait、notify、notifyAll方法的使用注意事项"><a href="#wait、notify、notifyAll方法的使用注意事项" class="headerlink" title="wait、notify、notifyAll方法的使用注意事项"></a><code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法的使用注意事项</h3><ol><li><strong>为什么<code>wait</code>必须在<code>synchronized</code>保护的同步代码中使用？</strong><ul><li>如果<code>notify</code>方法在<code>buffer.isEmpty()</code>和<code>wait</code>方法之间被调用，程序就会一直被<code>wait</code>而不会被唤醒。</li></ul></li><li><strong>为什么<code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code>被定义在<code>Object</code>类中，而<code>sleep</code>定义在<code>Thread</code>类中？</strong><ul><li>每个对象都有一把<code>monitor</code>监视器锁，<code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code>是锁级别的操作，它们的锁属于对象，所以把它们定义在<code>Object</code>类中是最合适。</li></ul></li><li><strong><code>wait</code>&#x2F;<code>notify</code>和<code>sleep</code>方法的异同？</strong><ul><li><strong>相同点</strong>：<ul><li>它们都可以让线程阻塞。</li><li>它们都可以响应<code>interrupt</code>中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出<code>InterruptedException</code>异常。</li></ul></li><li><strong>不同点</strong>：<ul><li><code>wait</code>方法必须在<code>synchronized</code>保护的代码中使用，而<code>sleep</code>方法并没有这个要求。</li><li>在同步代码中执行<code>sleep</code>方法时，并不会释放<code>monitor</code>锁，但执行<code>wait</code>方法时会主动释放<code>monitor</code>锁。</li><li><code>sleep</code>方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的<code>wait</code>方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。</li><li><code>wait</code>&#x2F;<code>notify</code>是<code>Object</code>类的方法，而<code>sleep</code>是<code>Thread</code>类的方法。</li></ul></li></ul></li></ol><h3 id="三类线程安全问题"><a href="#三类线程安全问题" class="headerlink" title="三类线程安全问题"></a>三类线程安全问题</h3><ul><li><strong>运行结果错误</strong>：多线程同时操作一个变量导致的运行结果错误。</li><li><strong>发布和初始化导致线程安全问题</strong>：<ul><li>示例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrongInit</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, String&gt; students;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WrongInit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                students.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;王小美&quot;</span>);<br>                students.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;钱二宝&quot;</span>);<br>                students.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;周三&quot;</span>);<br>                students.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;赵四&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Map&lt;Integer, String&gt; <span class="hljs-title function_">getStudents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> students;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">WrongInit</span> <span class="hljs-variable">multiThreadsError6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WrongInit</span>();<br>        System.out.println(multiThreadsError6.getStudents().get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>上述代码中创建<code>multiThreadsError6</code>对象后立刻就试图输出<code>student</code>的信息，而实际上此时线程可能还没启动完毕，导致空指针异常。</li></ul></li><li><strong>活跃性问题</strong>：<ul><li><strong>死锁</strong>：多个线程互相等待对方持有的资源，导致程序无法继续执行。</li><li><strong>活锁</strong>：线程一直处于忙碌状态，但程序始终得不到结果。例如，一个消息队列中某个消息由于自身被写错导致不能被正确处理，队列的重试机制会重新把它放在队列头进行优先重试处理，但这个消息本身无论被执行多少次都无法被正确处理，最终导致线程一直处于忙碌状态，但程序始终得不到结果。</li><li><strong>饥饿</strong>：线程需要某些资源时始终得不到，尤其是CPU资源，就会导致线程一直不能运行而产生的问题。例如，线程优先级过低，或者某个线程始终持有某个文件的锁，其他线程无法获取资源。</li></ul></li></ul><h3 id="哪些场景需要额外注意线程安全问题？"><a href="#哪些场景需要额外注意线程安全问题？" class="headerlink" title="哪些场景需要额外注意线程安全问题？"></a>哪些场景需要额外注意线程安全问题？</h3><ol><li><strong>访问共享变量或资源</strong>：例如访问共享对象的属性、访问<code>static</code>静态变量、访问共享的缓存等。</li><li><strong>依赖时序的操作</strong>：例如多个线程同时访问以下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<br>    x = <span class="hljs-number">7</span> * x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>不同数据之间存在绑定关系</strong>：例如IP和端口号，需要同时更新。</li><li><strong>对方没有声明自己是线程安全的</strong>：例如<code>ArrayList</code>，需要在外部手动用<code>synchronized</code>等方式保证并发安全。</li></ol><h3 id="为什么多线程会带来性能问题？"><a href="#为什么多线程会带来性能问题？" class="headerlink" title="为什么多线程会带来性能问题？"></a>为什么多线程会带来性能问题？</h3><ol><li><strong>调度开销</strong>：<ul><li><strong>上下文切换</strong>：线程数往往大于CPU核心数，操作系统会按照调度算法给每个线程分配时间片，线程调度会引起上下文切换，上下文切换的开销较大。</li><li><strong>缓存失效</strong>：线程调度后，CPU需要重新缓存新线程的数据，这也会带来一定的开销。</li></ul></li><li><strong>协作开销</strong>：<ul><li>为了保证线程安全，需要禁止编译器和CPU对共享数据进行重排序等优化，还需要频繁地将线程工作内存的数据刷新到主存中，然后再从主存刷新到其他线程的工作内存中，这会降低性能。</li></ul></li></ol><h3 id="使用线程池比手动创建线程好在哪里？"><a href="#使用线程池比手动创建线程好在哪里？" class="headerlink" title="使用线程池比手动创建线程好在哪里？"></a>使用线程池比手动创建线程好在哪里？</h3><ol><li><strong>解决线程生命周期的系统开销问题</strong>：线程池用一些固定的线程一直保持工作状态并反复执行任务。</li><li><strong>统筹内存和CPU的使用</strong>：线程池会根据配置和任务数量灵活地控制线程数量，避免线程过多导致内存溢出，或线程太少导致CPU资源浪费。</li><li><strong>统一管理资源</strong>：线程池可以统一管理任务队列和线程，可以统一开始或结束任务，便于数据统计。</li></ol><h3 id="线程池的各个参数的含义"><a href="#线程池的各个参数的含义" class="headerlink" title="线程池的各个参数的含义"></a>线程池的各个参数的含义</h3><ul><li>**<code>corePoolSize</code>**：核心线程数，线程池初始化时线程数默认为0，当有新的任务提交后，会创建新线程执行任务，此后线程数通常不会再小于<code>corePoolSize</code>。</li><li>**<code>maximumPoolSize</code>**：最大线程数，当任务队列满了之后，线程池会进一步创建新线程，最多可以达到<code>maximumPoolSize</code>。</li><li><strong><code>keepAliveTime</code> + 时间单位</strong>：当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的<code>keepAliveTime</code>，如果超过规定的时间，无事可做的线程就会被销毁。</li><li>**<code>ThreadFactory</code>**：线程工厂，用于创建线程。可以选择使用默认的线程工厂，也可以选择自己定制线程工厂，以方便给线程自定义命名。</li><li>**<code>workQueue</code>**：任务的阻塞队列，用于存储提交的任务。</li><li>**<code>handler</code>**：拒绝策略，当线程池无法处理新任务时，会根据拒绝策略进行处理。</li></ul><h3 id="线程池有哪4种拒绝策略？"><a href="#线程池有哪4种拒绝策略？" class="headerlink" title="线程池有哪4种拒绝策略？"></a>线程池有哪4种拒绝策略？</h3><ol><li>**<code>AbortPolicy</code>**：拒绝任务时抛出<code>RejectedExecutionException</code>异常。</li><li>**<code>DiscardPolicy</code>**：直接丢弃任务，不通知。</li><li>**<code>DiscardOldestPolicy</code>**：丢弃队列中存活时间最长的任务，为新任务腾出空间。</li><li>**<code>CallerRunsPolicy</code>**：将任务交由提交任务的线程执行。</li></ol><h3 id="有哪6种常见的线程池？什么是Java-8的ForkJoinPool？"><a href="#有哪6种常见的线程池？什么是Java-8的ForkJoinPool？" class="headerlink" title="有哪6种常见的线程池？什么是Java 8的ForkJoinPool？"></a>有哪6种常见的线程池？什么是Java 8的<code>ForkJoinPool</code>？</h3><ol><li>**<code>FixedThreadPool</code>**：核心线程数和最大线程数相同。</li><li>**<code>CachedThreadPool</code>**：线程数可以无限增加，但空闲线程会被回收。</li><li>**<code>ScheduledThreadPool</code>**：支持定时或周期性执行任务。</li><li>**<code>SingleThreadExecutor</code>**：使用唯一线程执行任务。</li><li>**<code>SingleThreadScheduledExecutor</code>**：<code>ScheduledThreadPool</code>的核心线程数设置为1。</li><li>**<code>ForkJoinPool</code>**：适合递归场景，每个线程都有自己的双端队列来存储分裂出来的子任务。</li></ol><h3 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h3><ol><li>**<code>LinkedBlockingQueue</code>**：对应<code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>，容量为<code>Integer.MAX_VALUE</code>，可以认为是无界队列。</li><li>**<code>SynchronousQueue</code>**：对应<code>CachedThreadPool</code>，队列容量为0，实际不存储任何任务，只负责对任务进行中转和传递。</li><li>**<code>DelayedWorkQueue</code>**：对应<code>ScheduledThreadPool</code>和<code>SingleThreadScheduledExecutor</code>，内部元素按照延迟时间长短排序。</li></ol><h3 id="为什么不应该自动创建线程池？"><a href="#为什么不应该自动创建线程池？" class="headerlink" title="为什么不应该自动创建线程池？"></a>为什么不应该自动创建线程池？</h3><p>因为上述的线程池中，要么线程没有约束，可以无限多；要么队列没有约束，可以无限大。当面对难于处理的大量任务时：</p><ul><li>线程创建得太多，会导致超过操作系统的上限而无法创建新线程，或者导致内存不足。</li><li>队列中堆积的任务太多，会导致大量堆积的任务占用大量内存，并发生<code>OOM</code>（<code>OutOfMemoryError</code>），这几乎会影响到整个程序，会造成很严重的后果。</li></ul><h3 id="合适的线程数量是多少？CPU核心数和线程数的关系？"><a href="#合适的线程数量是多少？CPU核心数和线程数的关系？" class="headerlink" title="合适的线程数量是多少？CPU核心数和线程数的关系？"></a>合适的线程数量是多少？CPU核心数和线程数的关系？</h3><p>调整线程池中的线程数量的主要目的是为了充分并合理地使用CPU和内存等资源，从而最大限度地提高程序的性能。</p><ul><li><strong>CPU密集型任务</strong>：最佳的线程数为CPU核心数的1~2倍。如果设置过多的线程数，会导致上下文切换增加，性能下降。</li><li><strong>IO密集型任务</strong>：线程数可以大于CPU核心数很多倍，因为IO操作较慢，需要更多的线程来充分利用CPU资源。</li></ul><h3 id="如何根据实际需要，定制自己的线程池？"><a href="#如何根据实际需要，定制自己的线程池？" class="headerlink" title="如何根据实际需要，定制自己的线程池？"></a>如何根据实际需要，定制自己的线程池？</h3><ul><li><strong>核心线程数</strong>：线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程。</li><li><strong>最大线程数</strong>：如果任务类型不固定，可以设置为<code>corePoolSize</code>的几倍。更好的办法是用不同的线程池执行不同类型的任务。</li><li><strong>阻塞队列</strong>：可以选择<code>ArrayBlockingQueue</code>等有限容量的队列，防止资源耗尽。</li><li><strong>线程工厂</strong>：可以传入自定义的线程工厂，以便根据业务信息进行命名，方便后续定位问题代码。</li><li><strong>拒绝策略</strong>：可以通过实现<code>RejectedExecutionHandler</code>接口来实现自己的拒绝策略。</li></ul><h3 id="如何正确地关闭线程池？shutdown和shutdownNow的区别？"><a href="#如何正确地关闭线程池？shutdown和shutdownNow的区别？" class="headerlink" title="如何正确地关闭线程池？shutdown和shutdownNow的区别？"></a>如何正确地关闭线程池？<code>shutdown</code>和<code>shutdownNow</code>的区别？</h3><ul><li>**<code>shutdown()</code>**：安全地关闭线程池，线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。但调用<code>shutdown()</code>后，如果还有新的任务被提交，线程池会根据拒绝策略拒绝后续新提交的任务。</li><li>**<code>isShutdown()</code>**：返回<code>true</code>或<code>false</code>，判断线程池是否已经开始关闭流程。</li><li>**<code>isTerminated()</code>**：判断线程池是否真正“终结”，即线程池已关闭并且所有任务都执行完毕。</li><li>**<code>awaitTermination()</code>**：尝试等待一段指定的时间，直到线程池“终结”。如果在等待时间内线程池已关闭并且任务都执行完毕，返回<code>true</code>；否则返回<code>false</code>。</li><li>**<code>shutdownNow()</code>**：尝试中断所有正在执行的任务，并返回任务队列中尚未执行的任务列表。线程池会尝试中断所有线程，但线程可能不会立即停止。</li></ul><h3 id="线程池实现“线程复用”的原理"><a href="#线程池实现“线程复用”的原理" class="headerlink" title="线程池实现“线程复用”的原理"></a>线程池实现“线程复用”的原理</h3><p>线程池通过将线程和任务解耦，让同一个线程可以从<code>BlockingQueue</code>中不断提取新任务来执行。核心原理是让每个线程去执行一个“循环任务”，在这个“循环任务”中，线程会不断检查是否有任务等待执行，如果有则直接执行任务的<code>run</code>方法，从而实现线程复用。</p><h3 id="你知道哪几种锁？分别有什么特点？"><a href="#你知道哪几种锁？分别有什么特点？" class="headerlink" title="你知道哪几种锁？分别有什么特点？"></a>你知道哪几种锁？分别有什么特点？</h3><p>根据分类标准，锁可以分为以下7大类别：</p><ol><li><strong>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</strong>：<ul><li><strong>偏向锁</strong>：适用于没有竞争的场景，线程可以直接获取锁，开销最小。</li><li><strong>轻量级锁</strong>：适用于有少量竞争的场景，线程会通过自旋尝试获取锁。</li><li><strong>重量级锁</strong>：适用于竞争激烈的场景，线程会进入阻塞状态。</li></ul></li><li><strong>可重入锁&#x2F;非可重入锁</strong>：<ul><li><strong>可重入锁</strong>：线程可以多次获取同一把锁，例如<code>ReentrantLock</code>。</li><li><strong>非可重入锁</strong>：线程不能多次获取同一把锁。</li></ul></li><li><strong>共享锁&#x2F;独占锁</strong>：<ul><li><strong>共享锁</strong>：多个线程可以同时持有锁，例如读锁。</li><li><strong>独占锁</strong>：同一时间只能有一个线程持有锁，例如写锁。</li></ul></li><li><strong>公平锁&#x2F;非公平锁</strong>：<ul><li><strong>公平锁</strong>：线程按照排队顺序获取锁。</li><li><strong>非公平锁</strong>：线程可能会插队获取锁。</li></ul></li><li><strong>悲观锁&#x2F;乐观锁</strong>：<ul><li><strong>悲观锁</strong>：在获取资源前先加锁，例如<code>synchronized</code>。</li><li><strong>乐观锁</strong>：在不加锁的情况下完成操作，例如<code>AtomicInteger</code>。</li></ul></li><li><strong>自旋锁&#x2F;非自旋锁</strong>：<ul><li><strong>自旋锁</strong>：线程在获取锁失败后会不断尝试获取锁。</li><li><strong>非自旋锁</strong>：线程在获取锁失败后会进入阻塞状态。</li></ul></li><li><strong>可中断锁&#x2F;不可中断锁</strong>：<ul><li><strong>可中断锁</strong>：线程在等待锁时可以被中断，例如<code>ReentrantLock</code>的<code>lockInterruptibly</code>方法。</li><li><strong>不可中断锁</strong>：线程在等待锁时不能被中断，例如<code>synchronized</code>。</li></ul></li></ol><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ul><li><strong>悲观锁</strong>：在获取资源前先加锁，例如<code>synchronized</code>关键字和<code>ReentrantLock</code>。</li><li><strong>乐观锁</strong>：在不加锁的情况下完成操作，例如<code>AtomicInteger</code>。</li><li><strong>数据库中的锁</strong>：<ul><li><strong>悲观锁</strong>：例如<code>SELECT ... FOR UPDATE</code>，在提交之前不允许第三方修改数据。</li><li><strong>乐观锁</strong>：通过版本号<code>version</code>字段实现，在更新数据时检查版本号是否一致。</li></ul></li></ul><h3 id="如何看到synchronized背后的“monitor锁”？"><a href="#如何看到synchronized背后的“monitor锁”？" class="headerlink" title="如何看到synchronized背后的“monitor锁”？"></a>如何看到<code>synchronized</code>背后的“monitor锁”？</h3><ul><li><strong>获取和释放monitor锁的时机</strong>：线程在进入被<code>synchronized</code>保护的代码块之前会自动获取锁，并且在退出时自动释放锁。</li><li><strong><code>synchronized</code>修饰的代码块</strong>：利用<code>monitorenter</code>和<code>monitorexit</code>指令实现。</li><li><strong><code>synchronized</code>修饰的方法</strong>：利用<code>ACC_SYNCHRONIZED</code>标志实现。</li></ul><h3 id="synchronized和Lock孰优孰劣，如何选择？"><a href="#synchronized和Lock孰优孰劣，如何选择？" class="headerlink" title="synchronized和Lock孰优孰劣，如何选择？"></a><code>synchronized</code>和<code>Lock</code>孰优孰劣，如何选择？</h3><ul><li>如果能不用最好既不使用<code>Lock</code>也不使用<code>synchronized</code>，优先使用<code>java.util.concurrent</code>包中的工具类。</li><li>如果<code>synchronized</code>关键字适合你的程序，尽量使用它，因为使用<code>Lock</code>时如果忘记在<code>finally</code>里<code>unlock</code>，可能会导致问题。</li><li>如果需要<code>Lock</code>的特殊功能（如尝试获取锁、可中断、超时功能等），则使用<code>Lock</code>。</li></ul><p>参考资料：</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/">Java并发编程</a></li><li><a href="https://juejin.cn/post/6896278031317663751">线程池详解</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">AQS详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Nginx部署静态网站</title>
    <link href="/2024/07/26/Nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    <url>/2024/07/26/Nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>按照网上教程安装Docker，并使用Docker容器部署静态网站，网上参考教程如下：</p><p>1、<a href="https://yeasy.gitbook.io/docker_practice/install">https://yeasy.gitbook.io/docker_practice/install</a></p><p>2、<a href="https://xie.infoq.cn/article/56b71146e70c590e220c468eb">https://xie.infoq.cn/article/56b71146e70c590e220c468eb</a></p><p>1.安装docker </p><p>（1）下载基本的包</p><p>sudo yum install -y yum-utils  </p><p>（2）给虚拟机联网</p><p>​     a.删除etc&#x2F;sysconfig&#x2F;network-scripts里面多余的文件并查看  </p><p>rm-rf ifcfg-enp0s3</p><p>   <img src="/img/articles/Linux/a.png"> </p><p>​     b.重启虚拟机和虚拟机网络并检查</p><p>systemctl restart network</p><p>   <img src="/img/articles/Linux/b.png"> </p><p>（4）配置阿里云镜像，加快下载速度</p><p>sudo yum-config-manager \</p><p>​      –add-repo \</p><p>​      <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p>（5）安装Docker引擎</p><p>​    sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</p><p>（6）检验安装结果</p><p>   <img src="/img/articles/Linux/1.png"> </p><p>2.将我电脑本地的静态网站代码压缩包移到到虚拟机里再解压</p><p>   <img src="/img/articles/Linux/2.png"> </p><p> 3.因目前Docker Hub国内无法访问，因此要配置国内可用镜像才能使用docker拉取镜像进行部署，修改docker配置文件如下：</p><p>   <img src="/img/articles/Linux/3.png"> </p><p>4.Linux防火墙开放端口并重启防火墙</p><p>   <img src="/img/articles/Linux/4.png"> </p><p>5.开启docker</p><p>   <img src="/img/articles/Linux/5.png">  </p><p>6.进入代码所在目录进行Nginx镜像拉取和运行docker镜像并绑定端口</p><p>  <img src="/img/articles/Linux/6.png">  </p><p>7.查看docker容器运行情况</p><p>  <img src="/img/articles/Linux/7.png"> </p><p>8.访问demo网站（在Windows电脑本地浏览器访问虚拟机的IP地址）</p><p>  <img src="/img/articles/Linux/8.png"> </p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记</title>
    <link href="/2024/07/18/Linux%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/18/Linux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-远程登陆到linux服务器"><a href="#1-远程登陆到linux服务器" class="headerlink" title="1.远程登陆到linux服务器"></a>1.远程登陆到linux服务器</h2><ol><li>为什么要远程？——-&gt;小组公网共享linux服务器</li><li>远程操作的软件：xshell（远程登陆），xftp（远程文件上传下载）</li><li>如何连接？：linux 的ifconfig命令</li><li>xshell可以实现远程进行linux命令操作，xftp远程文件的windows和xftp互传</li></ol><hr><h2 id="2-linux-vi和vim编辑器"><a href="#2-linux-vi和vim编辑器" class="headerlink" title="2.linux vi和vim编辑器"></a>2.linux vi和vim编辑器</h2><p>linux系统内置的vi文本编辑器（相当于windows的记事本）</p><p>vim是vi的增强版，有程序编辑能力</p><h3 id="2-1常用的三种模式："><a href="#2-1常用的三种模式：" class="headerlink" title="2.1常用的三种模式："></a>2.1常用的三种模式：</h3><ol><li>正常模式：用vim打开文档就直接进入的<strong>默认模式</strong>，可以上下左右移动光标，可以<strong>删除字符</strong>或<strong>删除整行</strong></li><li>插入模式：输入<code>i/I</code></li><li>命令行模式：读取，存盘，替换，离开vim，显示行号。<strong>从插入模式进入命令行模式—-&gt;先输入<code>esc</code>，再输入冒号（<code>:</code>）</strong></li></ol><h3 id="2-2vi-vim的快捷键："><a href="#2-2vi-vim的快捷键：" class="headerlink" title="2.2vi&#x2F;vim的快捷键："></a>2.2vi&#x2F;vim的快捷键：</h3><ol><li>vi&#x2F;vim的各种模式的切换：输入<code>vim filename</code>打开文件（默认模式），输入i&#x2F;I进入编辑模式 按esc回到默认模式，在默认模式输入：或者 &#x2F; 进入命令模式 按下esc键退出。<strong>在命令模式下：wq（保存退出），q（退出，不保存），q！（强制退出，不保存）</strong>。</li><li><strong>拷贝当前行：</strong><code>yy</code>，若要拷贝当前行向下5行（包括当前行） <code>5yy</code>（选中几行）然后输入p（粘贴）</li><li><strong>删除当前行：</strong><code>dd</code>，若要删除当前行向下5行（包括当前行） <code>5dd</code></li><li><strong>查找关键字：</strong>要在<em>命令行</em>下进行操作：进入命令行，然后输入**&#x2F;关键字**，回车查找，输入n是查找下一个</li><li><strong>设置文件行号：</strong><code>set nu</code>（设置），<code>set nonu</code>（取消文件行号）</li><li><strong>跳转文件首尾行：</strong>在<em>默认模式</em>下，<code>G</code>就是文件尾行，<code>gg</code>是文件首行。</li><li><strong>撤销动作：</strong>在<em>默认模式</em>下，输入<code>u</code>。</li><li><strong>快速定位到某一行：</strong>在<em>默认模式下</em>，输入20（定位到20行），再输入<code>shift+g</code></li><li>其他…看hsp文档</li></ol><hr><h3 id="2-3-关机重启"><a href="#2-3-关机重启" class="headerlink" title="2.3.关机重启"></a>2.3.关机重启</h3><ol><li><code>shutdown -h(halt的意思：停止) now</code> 立刻进行关机</li><li><code>shutdown -h 1</code>，提醒用户一分钟之后关机，与直接输入shutdown的效果一致</li><li><code>shutdown -r（reboot的意思） now</code> 现在重启计算机</li><li><code>halt</code> 关机</li><li><code>reboot</code> 重启计算机</li><li><code>sync</code> 把内存数据同步到磁盘：目前的<code>shutdown/reboot/halt</code>命令都会在关机前自动执行sync命令</li></ol><h4 id="2-3-1用户登陆或注销"><a href="#2-3-1用户登陆或注销" class="headerlink" title="2.3.1用户登陆或注销"></a>2.3.1用户登陆或注销</h4><ol><li>切换管理员账户 <code>su root</code> 细节：<code>su - root</code> 和<code>su root</code> ：前者用户是root（在root家），后者用户还是原用户（在ahao家），只是有了root权限</li><li>logout注销当前用户：注意必须是在 <em>非图形运行级别</em>（在shell下才行，退出当前用户），并且在 <em>运行级别为3</em> 下才有效。</li></ol><hr><h3 id="2-4-用户管理"><a href="#2-4-用户管理" class="headerlink" title="2.4.用户管理"></a>2.4.用户管理</h3><ol><li>linux是多用户操作系统，若要进行操作，首先要向系统申请用户账号。</li><li><strong>添加用户：</strong> <code>useradd 用户名</code> ，添加谁就会自动创建该用户的家目录，在&#x2F;home&#x2F;用户名 中。</li><li><code>useradd -d 指定目录 用户名</code> 在指定目录下（没有可以自动创建），创建用户名同名文件夹。</li><li><code>passwd 用户名</code> 给用户指定密码，若不写用户名则默认给当前用户设置。</li><li>显示当前用户所在的目录 <code>pwd</code></li><li>删除用户：<code>userdel 用户名</code> （会保留家目录），<code>userdel -r 用户名</code>（会连带家目录一起删除），但是两者都不能继续登陆了。</li><li>一般情况下建议保留家目录：工作资料要保留。</li></ol><h4 id="2-4-1-用户管理2"><a href="#2-4-1-用户管理2" class="headerlink" title="2.4.1 用户管理2"></a>2.4.1 用户管理2</h4><ol><li>查询用户信息指令：<code>id 用户名</code>，可以查询uid，gid和当前组</li><li>切换用户<code>su - 用户名</code> 注意：从权限高的用户切换到权限低的用户不需要输入密码，反之需要。切换回原来：exit&#x2F;logout</li><li>查看当前用户：<code>whoami（当前用户名）/who am i(首次登陆的用户)</code></li></ol><h4 id="2-4-2-用户组"><a href="#2-4-2-用户组" class="headerlink" title="2.4.2 用户组"></a>2.4.2 用户组</h4><ol><li>给权限相同的组进行分组</li><li><code>groupadd 组名</code> 进行添加，<code>groupdel 组名</code> 进行删除</li><li>linux特点：没有消息就是好消息。当默认创建一个用户时，系统会自动将用户分配给与用户名相同的组。</li><li>将用户指定组名进行添加：<code>useradd -g 用户组 用户名</code></li><li>将用户切换到另外的组：<code>usermod -g 用户组 用户名</code></li><li>用户组和相关文件：</li></ol><ul><li>&#x2F;etc&#x2F;passwd文件：用户配置文件，记录各种信息。每行含义：<em>用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shll</em></li><li>&#x2F;etc&#x2F;shadow文件：口令配置文件，每行含义：<em>登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</em></li><li>&#x2F;etc&#x2F;group文件：记录linux包含的组的信息，每行含义：<em>组名：口令：组标识号：组内用户列表</em></li><li>shell的作用：将口令进行解释，输入linux内核操作。</li></ul><hr><h2 id="3-实用指令"><a href="#3-实用指令" class="headerlink" title="3.实用指令"></a>3.实用指令</h2><h3 id="3-1运行级别"><a href="#3-1运行级别" class="headerlink" title="3.1运行级别"></a>3.1运行级别</h3><ol><li><p>0关机，1单用户（可以找回丢失的密码），2多用户状态下没有网络服务，3多用户状态下有网络服务（2 4用的少，这个用的多），4系统未使用保留给用户，5图形界面，6系统重启</p></li><li><p>常用3和5，init指令切换不同的运行级别：<code>init 3</code>切换至3</p></li><li><p>修改默认运行级别，在centos7以前，etc&#x2F;inittab文件中的</p><p><code>multi-user.target:analogous to runlevel 3 graphical.target:analogous to runlevel 5 </code>这两句话中</p></li><li><p>之后（centos7）用<code>systemctl get-default</code>命令查看当前用户级别<br><code>systemctl set-default TARGET.target（用户级别）</code>命令修改当前用户级别</p></li></ol><h3 id="3-2找回root密码"><a href="#3-2找回root密码" class="headerlink" title="3.2找回root密码"></a>3.2找回root密码</h3><ol><li>不同版本不同</li><li>以7之后为例：在开机界面按“e”，速度要快。</li><li>看老韩文档照抄就行。</li></ol><h3 id="3-3帮助指令"><a href="#3-3帮助指令" class="headerlink" title="3.3帮助指令"></a>3.3帮助指令</h3><ol><li><strong>man+指令</strong>：获取帮助信息，如<code>man ls</code>查看ls指令的帮助信息（ls -a列出包括 . 开头的隐藏文件，linux的隐藏文件以 . 开头）</li><li><strong>help+指令</strong></li></ol><h3 id="3-4文件目录指令"><a href="#3-4文件目录指令" class="headerlink" title="3.4文件目录指令"></a>3.4文件目录指令</h3><ol><li><strong>pwd</strong>：显示当前所在的绝对路径。相对路径：从当前目录开始找。</li><li><strong>ls显示文件</strong>：-l是以列表形式，-lh是以单位显示文件大小。</li><li><strong>cd切换</strong>：cd ~回到家目录，cd ..回到上一目录</li><li><strong>mkdir</strong>：<code>mkdir 选项 要创建的目录</code> 如-p：可以创建多级目录，<code>mkdir -p /home/animal/dog</code>，相应的目录都会创建</li><li><strong>rmdir</strong>：删除空目录，<code>rmdir 选项 要删除的空目录</code>，若要删除非空目录：<code>rm -rf 要删除的目录</code>：该命令会递归删除文件夹下所有的文件。（跑路指令rm -rf &#x2F;*）</li><li><strong>touch</strong>：创建一个空文件，<code>touch 文件名称</code></li><li><strong>cp</strong>：<code>cp 选项 source dest</code>：复制从源文件夹source到目标文件夹dest，-r：递归整个文件夹。第二次执行会覆盖，系统会提示。强制覆盖且不提示<code>\cp</code> 反斜杠cp</li><li><strong>rm指令</strong>：<code>rm 选项 要删除的目录或者文件</code>：-r：递归删除整个文件夹，-f：强制删除不提示，-rf：递归删除且不提示</li><li><strong>mv指令</strong>：移动文件与目录或者重命名。<code>mv 老文件 新文件（重命名）</code>，<code>mv 老文件位置 新位置（将文件移动到这个位置去）</code>，还可以移动并且重命名。<code>mv 老文件名 新路径/新名称</code>，对文件夹也是相同的操作</li><li><strong>cat指令</strong>：查看文件内容，<code>cat 选项 要查看的文件</code> 常用选项：-n，显示行号。<em>对于重要的文件推荐使用cat</em>，因为这个指令只能读不能改。为了方便浏览，一般会带上<strong>管道命令</strong> | more(将前一个指令的结果交给后面more的指令进行<em>交互</em>，如可以翻页等)</li><li><strong>more指令</strong>：是基于vi编辑器的文本过滤器，以全屏幕的方式按页显示文本文件的内容。<em>可以和cat配合使用，也可以单独使用。</em>more指令中的快捷键：<strong>空格键</strong>(向下翻页)，<strong>enter键</strong>（向下一行），<strong>q</strong>（离开文件，并且不再显示内容），<strong>ctrl+f</strong>（向下滚动一屏），<strong>ctrl+b</strong>（返回上一屏），**&#x3D;<strong>（输出当前的行号），</strong>:f**（输出文件名和当前行号）。</li><li><strong>less指令</strong>：与more类似，但比more更加强大，支持各种显示终端。less文件显示内容，并不是一次性全加载，而是根据显示需要加载，对大型文件效率更高。<strong>空格键</strong>：向下翻页，<strong>PageDown和PageUp</strong>：向上向下翻页。**&#x2F;字串<strong>：n：向下查找，N：向上查找。</strong>q**：离开less这个程序。</li><li><strong>echo指令</strong>：输出内容到控制台，<code>echo 选项 输出内容</code></li><li><strong>head指令</strong>：<code>head 文件名</code>默认查看文件的头十行内容。<code>head -n 5 文件名</code> -n指定查看文件头几行内容</li><li><strong>tail指令</strong>：与head相反，默认查看尾10行的内容，-n用法相同，<code>tail -f 文件名</code>实时追踪该文档的所有更新。</li><li><strong>箭头&gt;和&gt;&gt;指令</strong>:输出重定向和&gt;&gt;追加，echo和&gt;配合：将要输出的指令写在指定的文件中。&gt;会覆盖文件中的原内容，&gt;&gt;追加内容，原先的内容不会覆盖。如果没有这个文件，则会自动创建。</li></ol><ul><li>基本语法：</li><li><code>ls -l &gt; 文件</code> ls（列表）出来的内容写入文件中（覆盖）。</li><li><code>ls -al &gt;&gt; 文件</code>列表出来的内容追加到文件的末尾。</li><li><code>cat 文件1 &gt; 文件2</code>文件1内容覆盖文件2内容</li><li><code>echo &quot;内容&quot; &gt;&gt; 文件</code> 将要在控制台输出的内容追加到文件</li></ul><ol><li><strong>ln指令</strong>：</li></ol><ul><li><em>软链接</em>，也称为<em>符号链接</em>，类似于windows里面的快捷方式。主要存放了链接其他文件的路径。</li><li>说白了就是访问一个已经链接好的，就相当于访问那个被链接的文件，相当于创建桌面快捷方式来访问程序的意思。</li><li>语法：在当前目录下创建一个软链接到哪儿<code>ln -s 原文件或目录 软连接名(自定义软链接名，可以加路径，就是自定义的软链接创建到哪儿)</code></li><li>删除的话直接rm删除软链接名</li></ul><ol><li>history指令：查看已经执行过的历史命令。<code>history 10</code>:查看历史执行过的10条指令。<code>!5</code>：执行曾经执行过的第五条指令。</li></ol><h3 id="3-5时间日期指令"><a href="#3-5时间日期指令" class="headerlink" title="3.5时间日期指令"></a>3.5时间日期指令</h3><ol><li>date指令：显示当前日期：</li></ol><ul><li><code>date</code>：显示当前时间</li><li><code>date +%Y</code> ：显示当前年份<br><code>date +%m</code>：显示当前月份<br><code>date +%d</code>：显示当前是哪一天<br><code>date&quot;+%Y-%m-%d%H:%M:%S”</code>：显示年月日时分秒,按照固定格式</li><li><code>date -s 字符串时间</code>，可以设置当前系统时间。</li><li><code>cal 选项</code>：不加选项直接显示当前月的日历,<code>cal 2022</code>:显示2022年整年的日历。</li></ul><h3 id="3-6查找指令"><a href="#3-6查找指令" class="headerlink" title="3.6查找指令"></a>3.6查找指令</h3><ol><li><p>find指令：</p><ul><li><code>find 文件夹名 -name 文件名</code>：根据名称查找</li><li><code>find 文件夹名 -user 文件名</code>：按拥有者查找</li><li><code>find 文件夹名 -size 200M</code>：按文件大小查找（+是大于，-是小于，不写n是等于，我这个例子就是等于。还有单位有k，M，G）</li><li>文件夹名写<code>/</code>就是查全部</li></ul></li><li><p>locate指令：查找速度特别快，无需遍历整个文件系统，是建立locate数据库。第一次运行前，必须使用<strong>updatedb指令</strong>创建。</p></li><li><p>which指令：可以查看指令在哪个目录下</p></li><li><p>grep指令：grep过滤查找也就是只查找这一个，往往和管道符号</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|</span><br></code></pre></td></tr></table></figure><p>结合使用，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><ul><li><code>-n</code>显示匹配行和行号</li><li><code>-i</code>忽略字母大小写</li></ul></li></ol><h3 id="3-7压缩和解压"><a href="#3-7压缩和解压" class="headerlink" title="3.7压缩和解压"></a>3.7压缩和解压</h3><ol><li><p>gzip&#x2F;gunzip指令：gzip用于压缩文件，gunzip用于解压文件</p><ul><li><code>gzip 文件</code>：压缩文件为*.gz文件</li><li><code>gunzip 文件.gz</code>：解压缩gz文件</li></ul></li><li><p>zip&#x2F;unzip：往往用于文件夹压缩，项目打包发布。</p><ul><li><code>zip 选项 压缩成.zip 要压缩的内容</code></li><li><code>unzip 选项 文件名.zip</code></li><li><code>zip -r</code>：递归压缩，即压缩目录：将某一个文件夹以及下面的内容压缩。注意压缩目录必须用这个命令。</li><li><code>unzip -d 路径 要解压的文件.zip</code>：将文件解压到哪儿，要解压的文件前可加此文件的路径，更精确。</li></ul></li><li><p>tar指令：是打包指令，没有untar一说。最后打包的指令是.tar.gz文件。</p><ul><li><p>语法：<code>tar 选项 xxx.tar.gz(是打包以后的文件名) 打包的内容</code>，打包目录和文件都行。</p></li><li><p><code>-c</code>：产生.tar打包文件。</p><p><code>-v</code>：显示详细信息</p><p><code>-f</code>：指定压缩后的文件名</p><p><code>-z</code>：用gzip对文档进行压缩或解压</p><p><code>-x</code>：解包.tar文件</p></li><li><p>Linux只能压缩一个文件，而多个文件要先对多个文件进行打包才能压缩。</p></li></ul></li></ol><hr><h2 id="4-linux组的介绍"><a href="#4-linux组的介绍" class="headerlink" title="4.linux组的介绍"></a>4.linux组的介绍</h2><ol><li>每个用户必须属于一个组，不能独立于组外。</li><li>每个文件都有，所有者，所在组，其他组的概念。</li><li>文件属于哪一个用户创建的，就属于这个用户所在组，组内成员对这个文件有一定的权限，其他组成员没有。</li></ol><h3 id="4-1所有者"><a href="#4-1所有者" class="headerlink" title="4.1所有者"></a>4.1所有者</h3><ol><li>文件&#x2F;目录的所有者：一般来说，谁创建了该文件&#x2F;目录，谁就是所有者。</li><li>查看文件所有者命令：<code>ls -ahl </code>:查看当前目录下文件的所有者。</li><li>修改文件的所有者：<code>chown 要改成的用户名 文件名</code></li></ol><h3 id="4-2所在组"><a href="#4-2所在组" class="headerlink" title="4.2所在组"></a>4.2所在组</h3><ol><li>创建组，<code>groupadd 组名</code></li><li>添加用户 <code>useradd -g 组名 用户</code></li><li>所在组：当用户创建了文件以后，文件所在组就是用户所在组。</li><li>查看文件&#x2F;目录所在组指令：<code>ls -ahl</code>：第一个是用户名，第二个是组名。</li><li>修改文件所在组：<code>chgrp 组名 文件名</code></li></ol><h3 id="4-3其他组"><a href="#4-3其他组" class="headerlink" title="4.3其他组"></a>4.3其他组</h3><ol><li>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组：说白了就是除去操作的组就是其他组</li><li>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。<ul><li>添加：<code>usermod -g 新组名 用户名</code></li><li>修改：<code>usermod -d 目录名 用户名 改变该用户登陆的初始目录</code>：修改时必须要有<em>进入新目录的权限</em>。</li></ul></li></ol><h2 id="5-权限"><a href="#5-权限" class="headerlink" title="5.权限"></a>5.权限</h2><h3 id="5-1rwx权限"><a href="#5-1rwx权限" class="headerlink" title="5.1rwx权限"></a>5.1rwx权限</h3><ol><li>举例：<code>-rwxrw-r--1 root root 1213 Feb 2 09:39 abc</code><ul><li>前十位<code>-rwxrw-r--1</code></li><li>第零位<code>-</code>：第0位确定文件类型(d,-,I,c,b)，-就是没有<br>I是链接，相当于windows的快捷方式<br>d是目录，相当于windowsl的文件夹<br>c是字符设备文件，鼠标，键盘<br>b是块设备，比如硬盘</li><li>第1-3位<code>rwx</code>确定所有者（该文件的所有者）拥有该文件的权限。–User</li><li>第4-6位<code>rw-</code>确定所属组（同用户组的）拥有该文件的权限，-Group</li><li>第7-9<code>r--</code>位确定其他用户拥有该文件的权限-Other</li></ul></li><li>rwx权限：<ul><li>文件：</li><li>[r]代表可读(read:可以读取，查看</li><li>[w]代表可写(wite:可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件</li><li>[x]代表可执行(execute):可以被执行</li><li>目录：</li><li>[r]代表可读(read):可以读取，Is查看目录内容</li><li>[w]代表可写(wite:可以修改，对目录内创建+删除+重命名目录</li><li>[x]代表可执行(execute):可以进入该目录</li></ul></li><li>rwx举例：<ul><li><code>-rwxrw-r--1 root root 1213 Feb 2 09:39 abc</code></li><li><code>-（文件类型）rwx（文件拥有者的权限是读写执行）rw-（与文件拥有者同在一个组的权限是读写）r--（其他组成员对文件的权限是读）1（文件：硬连接数。 如果是目录：子目录数） root（用户） root（所在组） 1213（文件大小（字节），如果是文件夹，显示4096字节） Feb 2 09:39（最后修改日期） abc</code>（文件名）</li><li>在linux中也可以用数字来代表相应的权限：可用数字表示为：r&#x3D;4,W&#x3D;2,x&#x3D;1因此rwx&#x3D;4+2+1&#x3D;7</li></ul></li></ol><h3 id="5-2-chmod"><a href="#5-2-chmod" class="headerlink" title="5.2 chmod"></a>5.2 chmod</h3><ol><li><p>修改文件&#x2F;文件夹权限：</p><ul><li><p>第一种方式：+、-、&#x3D;变更权限。u：所有者，g：所有组，o：其他人，a：所有人(u、g、o的总和)</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">plaintext<br><span class="hljs-number">1</span>)chmod u=rwx,g=rx,o=<span class="hljs-variable language_">x</span> 文件/目录名 我要给后面的文件/目录的所有者rwx，所在组的成员rx，其他人<span class="hljs-variable language_">x</span>权限<br><span class="hljs-number">2</span>)chmod o+w 文件/目录名给其他用户赋予w的权限<br><span class="hljs-number">3</span>)chmod a-<span class="hljs-variable language_">x</span> 文件/目录名给所有人剔除<span class="hljs-variable language_">x</span>权限<br></code></pre></td></tr></table></figure></li><li><p>第二种方式：通过数字变更权限 r&#x3D;4 w&#x3D;2 x&#x3D;1<br>rwx&#x3D;4+2+1&#x3D;7<br><code>chmod u=rwx,g=rx,o=x 文件目录名</code><br>相当于<code>chmod 751 文件目录名</code></p></li></ul></li></ol><h3 id="5-3-chown"><a href="#5-3-chown" class="headerlink" title="5.3 chown"></a>5.3 chown</h3><ol><li>修改文件拥有者<ul><li><code>chown newowner（所有者名字） 文件/目录</code>：改变所有者</li><li><code>chown newowner:newgroup（所有者名字：所有者所在组） 文件/目录</code>：改变所有者和所在组</li><li><code>-R</code>：<code>chown -R 所有者 目录</code> 如果是目录则使其下所有子文件或目录递归生效</li></ul></li></ol><h3 id="5-4-chgrp"><a href="#5-4-chgrp" class="headerlink" title="5.4 chgrp"></a>5.4 chgrp</h3><ol><li>修改文件&#x2F;目录所在组<ul><li><code>chgrp newgroup(新组名) 文件/目录</code>改变所有组</li></ul></li></ol><h2 id="6-crond任务调度"><a href="#6-crond任务调度" class="headerlink" title="6.crond任务调度"></a>6.crond任务调度</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><ol><li>任务调度：是指系统在某个时间执行的特定命全或程序。</li><li>任务调度分类：<ul><li>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</li><li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</li></ul></li></ol><h3 id="6-2-crontab"><a href="#6-2-crontab" class="headerlink" title="6.2 crontab"></a>6.2 crontab</h3><h4 id="定时任务设置"><a href="#定时任务设置" class="headerlink" title="定时任务设置"></a>定时任务设置</h4><ol><li><p><strong>基本语法</strong>：<code>crontab 选项</code></p><ul><li><code>crontab -e</code>：编辑当前用户的定时任务。</li><li><code>crontab -l</code>：查看当前用户的定时任务。</li><li><code>crontab -r</code>：删除当前用户的定时任务。</li></ul></li><li><p><strong>定时任务格式</strong></p><ul><li>定时任务的格式为：<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>* * * * command<br></code></pre></td></tr></table></figure>其中，<code>command</code> 是要执行的命令，而前面的五个 <code>*</code> 分别表示：<ul><li>第一个 <code>*</code>：分钟（0-59）</li><li>第二个 <code>*</code>：小时（0-23）</li><li>第三个 <code>*</code>：日期（1-31）</li><li>第四个 <code>*</code>：月份（1-12）</li><li>第五个 <code>*</code>：星期几（0-7，其中 0 和 7 都表示星期天）</li></ul></li></ul></li><li><p><strong>示例</strong></p><ul><li><code>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</code>：每分钟执行一次 <code>ls -l /etc/</code> 命令，并将输出重定向到 <code>/tmp/to.txt</code> 文件中。</li><li><code>0 2 * * * echo &quot;Hello, World!&quot;</code>：每天凌晨 2 点执行一次 <code>echo &quot;Hello, World!&quot;</code> 命令。</li><li><code>0 0 1 * * echo &quot;Happy New Month!&quot;</code>：每月的第一天午夜执行一次 <code>echo &quot;Happy New Month!&quot;</code> 命令。</li><li><code>0 0 * * 0 echo &quot;Happy Sunday!&quot;</code>：每周日午夜执行一次 <code>echo &quot;Happy Sunday!&quot;</code> 命令。</li></ul></li><li><p><strong>占位符说明</strong></p><ul><li><code>*</code>：表示所有可能的值。例如，<code>*</code> 在分钟位置表示每分钟。</li><li><code>-</code>：表示一个范围。例如，<code>9-17</code> 表示 9 到 17 之间的所有值。</li><li><code>,</code>：表示列举多个值。例如，<code>1,3,5</code> 表示 1、3 和 5。</li><li><code>/</code>：表示每隔多少时间执行一次。例如，<code>*/2</code> 表示每隔 2 个单位执行一次。</li></ul></li><li><p><strong>特殊符号说明</strong></p><ul><li><code>@reboot</code>：在系统启动时执行一次。</li><li><code>@yearly</code> 或 <code>@annually</code>：每年执行一次。</li><li><code>@monthly</code>：每月执行一次。</li><li><code>@weekly</code>：每周执行一次。</li><li><code>@daily</code> 或 <code>@midnight</code>：每天执行一次。</li><li><code>@hourly</code>：每小时执行一次。</li></ul></li><li><p><strong>输出重定向</strong></p><ul><li>定时任务的输出可以重定向到文件中，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* * * * * <span class="hljs-built_in">ls</span> -l /etc/ &gt; /tmp/to.txt<br></code></pre></td></tr></table></figure>如果需要将错误信息也重定向到文件中，可以使用 <code>2&gt;&amp;1</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* * * * * <span class="hljs-built_in">ls</span> -l /etc/ &gt; /tmp/to.txt 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-3at定时任务"><a href="#6-3at定时任务" class="headerlink" title="6.3at定时任务"></a>6.3at定时任务</h3><ol><li>at命令是<strong>一次性</strong>定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了。</li><li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看：<code>ps -ef | grep atd</code>。<code>ps -ef</code>：检测当前正在运行的指令有哪些。</li><li>at命令格式：<code>at [选项] [时间]</code></li><li>Ctrl+D结束at命令的输入</li><li>at时间定义：<ul><li>at指定时间的方法：<ol><li>接受在当天的hh:mm(小时：分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。例如：04:00</li><li>便用midnight(深夜)，noon(中午)，teatime(饮茶时间，一般是下午4点)等比较摸糊的词语来指定时间。</li><li>采用12小时计时制，即在时间后面加上AM(上午)或PM(下午)来说明是上午还是下午。例如：12pm。</li><li>指定命令执行的具体日期，指定格试为month day(月日)或mm&#x2F;dd&#x2F;yy(月&#x2F;日&#x2F;年)或dd.mm.yy（日.月.年)，指定的日期必须跟在指定时间的后面。例如：04:00 2021-03-1。</li><li>使用相对计时法。指定格式为：now+count time-units,now就是当前时间，time-units是时间单位，这里能够是minutes(分钟)、hours(小时)、days(天)、weeks(星期)。count是时间的数量，几天，几小时。例如：now+5 minutes。（五分钟以后）</li><li>直接使用today(今天)、tomorrow(明天)来指定完成命令的时间。</li></ol></li></ul></li></ol><h2 id="7-linux挂载，磁盘分区"><a href="#7-linux挂载，磁盘分区" class="headerlink" title="7.linux挂载，磁盘分区"></a>7.linux挂载，磁盘分区</h2><ol><li>原理介绍：Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</li><li>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</li><li>示意图：进入到一个目录就是访问某个分区了，就是逻辑存储和物理存储之间的映射。</li><li>查看所有设备挂载的情况：<code>lsblk或者lsblk -f</code>，-f：有分区情况，uuid分区唯一标识符，mountpoint挂载点。</li><li>如果硬盘一满了导致&#x2F;home不够用了，可以加一块硬盘挂载到&#x2F;home，达到扩容的效果，其他同理。</li></ol><h3 id="7-1-linux分区介绍"><a href="#7-1-linux分区介绍" class="headerlink" title="7.1 linux分区介绍"></a>7.1 linux分区介绍</h3><ol><li>硬盘说明：<ul><li>Linux硬盘父IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘。</li><li>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。”×”为盘号(a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘)，“</del>”代表分区前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</li><li>对于SCSI硬盘，则标识为“sdx~”,SCSI硬盘是用”sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</li></ul></li><li>磁盘情况查询：<ul><li><code>df -h</code>查询系统整体磁盘使用情况</li><li><code>du -h</code>查询指定目录的磁盘占用情况,默认为当前目录。<ul><li>-s 指定目录占用大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>–max-depth&#x3D;1 子目录深度</li><li>-c 列出明细的同时，增加汇总值</li></ul></li></ul></li></ol><h2 id="8-Linux网络配置"><a href="#8-Linux网络配置" class="headerlink" title="8.Linux网络配置"></a>8.Linux网络配置</h2><h3 id="8-1-NAT网络"><a href="#8-1-NAT网络" class="headerlink" title="8.1 NAT网络"></a>8.1 NAT网络</h3><ol><li><p>网络配置指令：</p><ul><li>windows查看VMnet8网络配置：ipconfig指令</li><li>linux查看网络配置：ifconfig</li><li>ping：测试主机之间网络的连通性</li></ul></li><li><p>linux网络配置：</p><ul><li><p>自动获取ip，缺点是每次获取的ip都不一样</p></li><li><p>指定ip：直接修改配置文件来指定ip,并可以连接到外网（程序员推荐）编辑<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>要求：将ip地址配置的静态的，比如：ip地址为192.168.200.130。</p></li><li><p>ifcfg-ens33 文件说明</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">plaintext<br><span class="hljs-attribute">DEVICE</span>=eth0#接口名（设备，网卡）<br><span class="hljs-attribute">HWADDR</span>=00:0C:2X:6x:0x:Xx#MAC地址<br><span class="hljs-attribute">TYPE</span>=Ethernet#网络类型（通常是Ethemet)<br><span class="hljs-attribute">UUID</span>=926a57ba-92c6-4231-bacb-f27e5e6a9f44#随机id<br><span class="hljs-comment">#系统启动的时候网络接口是否有效(yes/no)</span><br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-comment">#IP的配置方法[none|static|bootpdhcp](引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议)</span><br><span class="hljs-attribute">BOOTPROTO</span>=static<br><span class="hljs-comment">#IP地址</span><br><span class="hljs-attribute">IPADDR</span>=192.168.200.130<br><span class="hljs-comment">#网关</span><br><span class="hljs-attribute">GATEWAY</span>=192.168.200.2<br><span class="hljs-comment">#域名解析器</span><br><span class="hljs-attribute">DNS1</span>=192.168.200.2<br></code></pre></td></tr></table></figure></li><li><p>在vm的虚拟网络编辑器配置上也要修改</p></li></ul></li></ol><h3 id="8-2-主机名和hosts映射"><a href="#8-2-主机名和hosts映射" class="headerlink" title="8.2 主机名和hosts映射"></a>8.2 主机名和hosts映射</h3><ol><li>设置主机名<ul><li>为了方便记忆，可以给Linux系统设置主机名，也可以根据需要修改主机名<code>vim /etc/hostname</code></li><li>指令hostname：查看主机名</li><li>修改文件在&#x2F;etc&#x2F;hostname指定</li><li>修改后，重启生效</li></ul></li><li>设置hosts映射<ul><li>windows：在C:\Windows\System32\drivers\etc\hosts 文件指定即可<br>案例：192.168.200.130 hspedu100</li><li>linux：在&#x2F;etc&#x2F;hosts文件 指定<br>案例：192.168.200.1 ThinkPad-PC</li><li>通过<code>ping 主机名</code>来测试连通性。</li></ul></li><li>主机名解析过程分析(Hosts、DNS)<ul><li>Hosts是什么：一个文本文件，用来记录IP和Hostname(主机名)的映射关系</li><li>DNS：<br>1.DNS,就是Domain Name System的缩写，翻译过来就是域名系统<br>2.是互联网上作为域名和P地址相互映射的一个分布式数据库</li></ul></li><li>举例：当用户输入一个网站<ul><li>浏览器先检查浏监器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析；如果没有检查操作系统DNS解析器缓存，如果有直接返回IP完成解析。这两个缓存，可以理解为本地解析器缓存。</li><li>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的P地址(DNS解析记录)如在cmd窗口中输入<code>ipconfig /displaydns //DNS域名解析缓存</code>还有<code>ipconfig /flushdns //手动清理dns缓存</code>。</li><li>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</li><li>如果 本地DNS解析器缓存 和 hosts文件 中均没有找到对应的IP,则到域名服务DNS进行解析域。</li></ul></li></ol><h2 id="9-进程管理"><a href="#9-进程管理" class="headerlink" title="9.进程管理"></a>9.进程管理</h2><ol><li>进程，就比如windows任务管理器里面的进程。程序运行起来就是一个进程。在LINUX中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号(id,进程号)&#x3D;&gt;windows &#x3D;linux。</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</li></ol><h3 id="9-1ps指令"><a href="#9-1ps指令" class="headerlink" title="9.1ps指令"></a>9.1ps指令</h3><ol><li>ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。</li><li>可以结合管道命令来过滤信息，比如我想看看有没有sshd服务：<code>ps -aux | grep sshd</code></li></ol><h3 id="9-3终止进程"><a href="#9-3终止进程" class="headerlink" title="9.3终止进程"></a>9.3终止进程</h3><ol><li><p>kill和killall：若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用killall命令来完成此项任务。</p></li><li><p><code>kill [选项] 进程号</code>（功能描述：通过进程号杀死&#x2F;终止进程）<br><code>killall 进程名称</code>（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用)</p></li><li><p>常用选项</p><p><code>-9</code>：表示强迫进程立即停止</p></li></ol><h3 id="9-4查看进程树"><a href="#9-4查看进程树" class="headerlink" title="9.4查看进程树"></a>9.4查看进程树</h3><ol><li>基本语法：<code>pstree [选项]</code>，可以更加直观的来看进程信息</li><li>常用选项:<ul><li><code>-P</code>：显示进程的PID</li><li><code>-u</code>：显示进程的所属用户</li></ul></li></ol><h3 id="9-5服务管理"><a href="#9-5服务管理" class="headerlink" title="9.5服务管理"></a>9.5服务管理</h3><ol><li>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的情求，比如(mysqld,sshd 防火墙等），因此我们又称为守护程，是Linux中非常重要的知识点。</li><li>service管理指令：<ul><li><code>service 服务名 [start|stop|restart|reload|status]</code></li><li>在CentoS7.0后很多服务不再使用service,而是systemctl(后面专门讲)</li><li>service指令管理的服务在&#x2F;etc&#x2F;init.d查看</li></ul></li><li>查看服务名：<ul><li>方式1：使用<code>setup</code> -&gt; 系统服务 就可以看到全部。带星号的为自启动</li><li>方式2：<code>/etc/init.d</code> 看到service指令管理的服务<code>ls -l /etc/init.d</code></li></ul></li><li>checkconfig指令<ul><li>语法：<ul><li>查看服务<code>chkconfig --list [|grep xxx]</code></li><li><code>chkconfig 服务名 --list</code></li><li><code>chkconfig --level 5 服务名 on/off</code></li></ul></li><li>使用细节：chkconfig重新设置服务后自启动回或关闭，需要重启机器reboot生效。</li></ul></li><li>systemctl管理指令<ul><li>基本语法：<code>systemctl [start|stop|restart|status] 服务名</code></li><li>systemctl指令管理的服务在&#x2F;usr&#x2F;Iib&#x2F;systemd&#x2F;system查看</li><li>systemctli设置服务的自启动状态<br>1.<code>systemctl list-unit-files [|grep服务名]</code>（查看服务开机启动状态，grep可以进行过滤）<br>2.<code>systemctl enable 服务名</code>（设置服务开机启动）<br>3.<code>systemctl disable 服务名</code>（关闭服务开机启动）<br>4.<code>systemct is-enabled 服务名</code>（查询某个服务是否是自启动的）</li><li>防火墙：防止重要端口被访问</li><li>细节讨论：<br>1.关闭或者启用防火墙后，立即生效。[telnet测试某个端口即可]<br>2.这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。<br>3.如果希望设置某个服务自启动或关闭永久生效，要使用<code>systemctl [enable|disable] 服务名</code></li></ul></li><li>firewall指令<ul><li>打开端口：<code>firewall-cmd --permanent --add-port=端口号/协议</code><br>关闭端口：<code>firewall-cmd --permanent --remove-port=端口号/协议</code><br>重新载入，才能生效：<code>firewall-cmd --reload</code><br>查询端口是否开放：<code>firewall-cmd --query-port=端口/协议</code></li></ul></li><li>动态监控进程<ul><li>top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。</li><li>语法：<code>top 选项</code></li><li>直接top，默认-d是三秒</li></ul></li><li>监控网络状态<ul><li>查看系统网络情况netstat：基本语法，<code>netstat [选项]</code></li><li>选项说明：<ul><li>-an：按一定顺序排列输出</li><li>-p：显示哪个进程在调用</li></ul></li></ul></li></ol><h2 id="10-rpm与yum"><a href="#10-rpm与yum" class="headerlink" title="10.rpm与yum"></a>10.rpm与yum</h2><h3 id="10-1rmp"><a href="#10-1rmp" class="headerlink" title="10.1rmp"></a>10.1rmp</h3><ol><li><p>介绍：rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager(RedHats软件包管理工具)的缩写，类以windows的setup.exe,这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p></li><li><p>rpm包的简单查询指令：查询已安装的rpm列表<code>rpm -qa|grep xx</code></p></li><li><p>其他查询指令：</p><ul><li><code>rpm-qa</code>：查询所安装的所有rpm软件包<br><code>rpm -qa | more</code><br><code>rpm -qa | grep X [rpm -qa | grep firefox]</code></li></ul></li><li><p>rpm包的管理：</p><ul><li>卸载rpm包语法：<code>rpm -e RPM包的名称 //erase</code></li><li>安装rpm包的语法：<code>rpm -ivh RPM包全路径名称</code></li><li>参数说明：i&#x3D;install安装，v&#x3D;verbose提示，h&#x3D;hash进度条</li></ul></li></ol><h3 id="10-2yum"><a href="#10-2yum" class="headerlink" title="10.2yum"></a>10.2yum</h3><ol><li>介绍：Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并目且安装，可以<strong>自动处理依赖性关系</strong>，并目一次安装所有依赖的软件包。</li><li>yum的基本指令：查询yum服务器是否有需要安装的软件<br><code>yum list|grep xx软件列表</code><br>安装指定的yum包<br><code>yum install xxx 下载安装</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java限制接口访问</title>
    <link href="/2024/07/12/Java-%E9%99%90%E5%88%B6%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/07/12/Java-%E9%99%90%E5%88%B6%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="接口访问限制实现"><a href="#接口访问限制实现" class="headerlink" title="接口访问限制实现"></a>接口访问限制实现</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>限制用户在一定时间内只能访问接口的次数。</p><h2 id="后端限制方法"><a href="#后端限制方法" class="headerlink" title="后端限制方法"></a>后端限制方法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>1.通过 Redis 记录请求次数，如果超过限制则拒绝访问。同时设置 Redis 的 key 的时效性，过期自动销毁。</p><p>2.使用限流器</p><h3 id="自定义注解（Java）"><a href="#自定义注解（Java）" class="headerlink" title="自定义注解（Java）"></a>自定义注解（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求限制的自定义注解</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Target</span> 注解可修饰的对象范围：</span><br><span class="hljs-comment"> *         - ElementType.METHOD: 作用于方法</span><br><span class="hljs-comment"> *         - ElementType.TYPE: 作用于类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Retention</span> 定义注解的生命周期：</span><br><span class="hljs-comment"> *         - RetentionPolicy.RUNTIME: 在运行时有效</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Inherited</span> 表示注解可被继承</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br>    <span class="hljs-comment">// 失效时间（秒）</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">seconds</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 最大请求次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置拦截器（Java）"><a href="#配置拦截器（Java）" class="headerlink" title="配置拦截器（Java）"></a>配置拦截器（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LimitInterceptor.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisCache redisCache;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>            <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>            <span class="hljs-type">AccessLimit</span> <span class="hljs-variable">accessLimit</span> <span class="hljs-operator">=</span> hm.getMethodAnnotation(AccessLimit.class);<br>            <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span> accessLimit.seconds(); <span class="hljs-comment">// 失效时间（秒）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> accessLimit.maxCount(); <span class="hljs-comment">// 最大请求次数</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> request.getServletPath() + request.getSession().getId();<br><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (redisCache.getCacheObject(key) != <span class="hljs-literal">null</span>) &#123;<br>                count = (Integer) redisCache.getCacheObject(key);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 第一次访问</span><br>                redisCache.setCacheObject(key, <span class="hljs-number">1</span>);<br>                redisCache.expire(key, seconds, TimeUnit.SECONDS); <span class="hljs-comment">// 设置缓存失效时间</span><br>                logger.info(<span class="hljs-string">&quot;&#123;&#125; 第一次访问&quot;</span>, key);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; maxCount) &#123;<br>                <span class="hljs-comment">// 增加访问次数</span><br>                redisCache.incr(key, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 超出访问次数</span><br>                logger.error(<span class="hljs-string">&quot;超出访问次数&quot;</span>);<br>                render(response, <span class="hljs-string">&quot;请求次数过于频繁！&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response 响应对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg      返回消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(HttpServletResponse response, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>        out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(RespBean.error(msg)));<br>        out.flush();<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册拦截器（Java）"><a href="#注册拦截器（Java）" class="headerlink" title="注册拦截器（Java）"></a>注册拦截器（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> LimitInterceptor <span class="hljs-title function_">limitHandlerInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitInterceptor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(limitHandlerInterceptor());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在-Controller-的接口加上注解（Java）"><a href="#在-Controller-的接口加上注解（Java）" class="headerlink" title="在 Controller 的接口加上注解（Java）"></a>在 Controller 的接口加上注解（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br><span class="hljs-meta">@AccessLimit(seconds = 6, maxCount = 1)</span> <span class="hljs-comment">// 用户重复访问该接口必须间隔 6 秒及以上</span><br><span class="hljs-keyword">public</span> RespBean <span class="hljs-title function_">addEmp</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Employee employee)</span> &#123;<br>    <span class="hljs-keyword">if</span> (employeeService.addEmp(employee)) &#123;<br>        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是微服务？</title>
    <link href="/2024/06/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/06/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="单体架构："><a href="#单体架构：" class="headerlink" title="单体架构："></a>单体架构：</h2><ul><li>将业务的所有功能集中在一个项目中开发，打成一个包部署。</li><li><strong>优点</strong>：架构简单，部署成本低。</li><li><strong>缺点</strong>：耦合度高。</li></ul><hr><h2 id="分布式架构："><a href="#分布式架构：" class="headerlink" title="分布式架构："></a>分布式架构：</h2><ul><li>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，成为一个服务</li><li>优点：降低服务耦合，有利于服务升级拓展</li></ul><hr><h2 id="微服务："><a href="#微服务：" class="headerlink" title="微服务："></a>微服务：</h2><ul><li>微服务是一种经过良好结构设计的分布式架构方案，微服务架构特征：</li><li><strong>单一职责</strong>：微服务拆分力度更小，每一服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li><li><strong>面向服务</strong>：微服务对外暴露业务接口</li><li><strong>自治</strong>：团队独立、技术独立、数据独立、部署独立</li><li><strong>隔离性强</strong>：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><h5 id="微服务结构："><a href="#微服务结构：" class="headerlink" title="微服务结构："></a>微服务结构：</h5><p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是 SpringCloud 和阿里巴巴的 Dubbo。</p><h6 id="Dubbo："><a href="#Dubbo：" class="headerlink" title="Dubbo："></a>Dubbo：</h6><ol><li>注册中心：zookeeper、Redis</li><li>服务远程调用：Dubbo 协议</li><li>配置中心：无</li><li>服务网关：无</li><li>服务监控和保护：dubbo-admin，功能弱</li></ol><h6 id="SpringCloud："><a href="#SpringCloud：" class="headerlink" title="SpringCloud："></a>SpringCloud：</h6><ol><li>注册中心：Eureka、Consul</li><li>服务远程调用：Feign (http 协议)</li><li>配置中心：SpringCloudConfig</li><li>服务网关：SpringCloudGateway、Zuul</li><li>服务监控和保护：Hystrix</li></ol><h6 id="SpringCloudAlibaba："><a href="#SpringCloudAlibaba：" class="headerlink" title="SpringCloudAlibaba："></a>SpringCloudAlibaba：</h6><ol><li>注册中心：Nacos、Eureka</li><li>服务远程调用：Dubbo、Feign</li><li>配置中心：SpringCloudConfig、Nacos</li><li>服务网关：SpringCloudGateway、Zuul</li><li>服务监控和保护：Sentinel</li></ol><hr><h2 id="SpringCloud：-1"><a href="#SpringCloud：-1" class="headerlink" title="SpringCloud："></a>SpringCloud：</h2><p>是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a><br>SpringCloud 继承了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验：<br>– 服务注册发现：Eureka、Nacos、Consul<br>– 服务远程调用：OpenFeign、Dubbo<br>– 服务链路监控：Zipkin、Sleuth<br>– 统一配置管理：SpringCloudConfig、Nacos<br>– 统一网关路由：SpringCloudGateway、Zuul<br>– 流控、降级、保护：Hystix、Sentinel</p><h5 id="SpringCloud-与-SpringBoot-的版本兼容关系如下："><a href="#SpringCloud-与-SpringBoot-的版本兼容关系如下：" class="headerlink" title="SpringCloud 与 SpringBoot 的版本兼容关系如下："></a>SpringCloud 与 SpringBoot 的版本兼容关系如下：</h5><table><thead><tr><th><strong>ReleaseTrain</strong></th><th><strong>BootVersion</strong></th></tr></thead><tbody><tr><td>2020.0.x aka ilford</td><td>2.4.x</td></tr><tr><td>Hoxton</td><td>2.2.x,2.3.x (Starting with SR3.5；SR5 用 2.2.x、SR5 以上用 2.3.x)</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><h5 id="服务拆分注意事项："><a href="#服务拆分注意事项：" class="headerlink" title="服务拆分注意事项："></a>服务拆分注意事项：</h5><ol><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ol><h5 id="微服务远程调用："><a href="#微服务远程调用：" class="headerlink" title="微服务远程调用："></a>微服务远程调用：</h5><ul><li>基于 RestTemplate 发起的 http 请求实现远程调用</li><li>http 请求交作远程调用是与语言无关的调用，只要指导对方的 ip、端口、接口路径、请求参数即可</li></ul><h6 id="1-注册-RestTemplate"><a href="#1-注册-RestTemplate" class="headerlink" title="1. 注册 RestTemplate"></a>1. 注册 RestTemplate</h6><p>在 order-service 的 OrderApplication 中注册 RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建RestTemplate并注入Spring容器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-服务远程调用-RestTemplate"><a href="#2-服务远程调用-RestTemplate" class="headerlink" title="2. 服务远程调用 RestTemplate"></a>2. 服务远程调用 RestTemplate</h6><p>修改 order-service 中的 OrderService 的 queryOrderById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br> <br><span class="hljs-keyword">public</span> Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Long orderId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.findById(orderId);<br>    <span class="hljs-comment">// 2.利用RestTemplate发起http请求，查询用户</span><br>    <span class="hljs-comment">// 2.1.url路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();<br>    <span class="hljs-comment">// 2.2.发送http请求，实现远程调用</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, User.class);        <span class="hljs-comment">//(url,返回值类型)</span><br>    <span class="hljs-comment">// 3.封装user到Order</span><br>    order.setUser(user);<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="提供者与消费者："><a href="#提供者与消费者：" class="headerlink" title="提供者与消费者："></a>提供者与消费者：</h5><ul><li><strong>服务提供者</strong>：一次业务中，被其他微服务调用的服务 (提供接口给其他微服务)</li><li><strong>服务消费者</strong>：一次业务中，调用其他微服务的服务 (调用其他微服务提供的接口)</li><li>提供者与消费者角色其实是相对的，一个服务可以同时是服务提供者和服务消费者</li></ul><h5 id="eureka-的作用："><a href="#eureka-的作用：" class="headerlink" title="eureka 的作用："></a>eureka 的作用：</h5><ol><li>服务消费者该如何获取服务提供者的地址信息？<ul><li>服务提供者启动时向 eureka 注册自己的信息</li><li>eureka 保存这些信息</li><li>消费者根据服务名称向 eureka 拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者该如何选择？<ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li></ul></li><li>消费者如何得知服务提供者的健康状态？<ul><li>服务提供者会每隔 30 秒向 EurekaServer 发送心跳请求，报告健康状态</li><li>eureka 会更新记录服务列表信息，心跳不正常会被剔除</li><li>消费者就可以拉渠道最新的信息</li></ul></li></ol><h5 id="在-eureka-架构中，微服务角色有两类："><a href="#在-eureka-架构中，微服务角色有两类：" class="headerlink" title="在 eureka 架构中，微服务角色有两类："></a>在 eureka 架构中，微服务角色有两类：</h5><ol><li>EurekaServer：服务端，注册中心<ul><li>记录服务信息</li><li>心跳监控</li></ul></li><li>EurekaClient：客户端<ul><li>provider：服务提供者，例如案例中的 user-service<ul><li>注册自己的信息到 EurekaServer</li><li>每隔 30 秒向 EurekaServer 发送心跳</li></ul></li><li>consumer：服务消费者，例如案例中的 order-service<ul><li>根据服务名称从 EurekaServer 拉取服务列表</li><li>根据服务列表作负载均衡，选一个微服务后发起远程调用</li></ul></li></ul></li></ol><h5 id="搭建-EuerkaServer："><a href="#搭建-EuerkaServer：" class="headerlink" title="搭建 EuerkaServer："></a>搭建 EuerkaServer：</h5><ol><li>创建项目，引入 spring-cloud-starter-netflix-eureka-server 的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>编写启动类，添加 @EnableEurekaServer 注解</li><li>添加 application.yml 文件，编写下面的配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span> <span class="hljs-comment"># 服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eurekaserver</span> <span class="hljs-comment"># eureka的服务名称</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span>  <span class="hljs-comment"># eureka的地址信息</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h5 id="注册-user-service："><a href="#注册-user-service：" class="headerlink" title="注册 user-service："></a>注册 user-service：</h5><ol><li>在 user-service 项目引入 spring-cloud-starter-netflix-eureka-client 的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>在 application.yml 文件，编写下面的配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userserver</span> <span class="hljs-comment"># user的服务名称</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span>  <span class="hljs-comment"># user的地址信息</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><ol><li>另外，我们可以将 user-service 多次启动，模拟多实例部署，但为了避免端口冲突，需要修改端口设置：<br><code>Serices窗口中，选中UserApplication右键点击Copy Configuration；修改Environment中的VM options项为：-Dserver.port=8082</code></li></ol><h5 id="在-order-service-完成服务拉取："><a href="#在-order-service-完成服务拉取：" class="headerlink" title="在 order-service 完成服务拉取："></a>在 order-service 完成服务拉取：</h5><p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡<br>\1. 修改 OrderService 的代码，修改访问的 url 路径，用服务名代替 ip、端口：<br><code>String url = &quot;http://userservice/user/&quot; + order.getUserId();</code></p><ol><li>在 order-service 项目的启动类 OrderApplication 中的 RestTemplate 添加负载均衡注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Eureka-总结："><a href="#Eureka-总结：" class="headerlink" title="Eureka 总结："></a>Eureka 总结：</h5><ol><li>搭建 EurekaServer<ol><li>引入 eureka-server 依赖</li><li>添加 @EnableEurekaServer 注解</li><li>在 application.yml 中配置 eureka 地址</li></ol></li><li>服务注册<ol><li>引入 eureka-client 依赖</li><li>在 application.yml 中配置 eureka 地址</li></ol></li><li>服务发现<ol><li>引入 eureka-client 依赖</li><li>在 application.yml 中配置 eureka 地址</li><li>给 RestTemplate 添加 @LoadBelanced 注解</li><li>用服务提供者的服务名称远程调用</li></ol></li></ol><hr><h2 id="Ribbon-负载均衡："><a href="#Ribbon-负载均衡：" class="headerlink" title="Ribbon 负载均衡："></a>Ribbon 负载均衡：</h2><h5 id="负载均衡流程："><a href="#负载均衡流程：" class="headerlink" title="负载均衡流程："></a>负载均衡流程：</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">oeder-service<br><span class="hljs-bullet">        1.</span> 发起请求：http://userservice/user/1<br>到RibbonLoadBanlancerclient<br><span class="hljs-bullet">        2.</span> 获取url中的服务id：userservicr<br>到DynamicServerListLoadBalancer<br><span class="hljs-bullet">        3.</span> 拉取userservice<br><span class="hljs-bullet">        4.</span> 返回服务列表localhost:8081、localhost8082<br>到DynamicServerListLoadBalancer<br><span class="hljs-bullet">        5.</span> 服务器负载均衡localhost:8081、localhost8082<br>到IRule<br><span class="hljs-bullet">        6.</span> 选择某个服务localhost:8081<br>到RibbonLoadBanlancerclient<br><span class="hljs-bullet">        7.</span> 修改url，发起请求：http://localhost:8081/user/1<br><span class="hljs-bullet">        8.</span> 请求到8081或8082<br>到user-service8081或user-service8082<br></code></pre></td></tr></table></figure><h5 id="负载均衡策略："><a href="#负载均衡策略：" class="headerlink" title="负载均衡策略："></a>负载均衡策略：</h5><ol><li>RoundRobinRule：<br>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则</li><li>AvailabilityFilteringRule：<ul><li>对以下两种服务器进行忽略：<ol><li>在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为” 短路” 状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。</li><li>并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上线，可以由客户端的 <code>&lt;clientName&gt;&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code> 属性进行配置。</li></ol></li></ul></li><li>WeightedResponseTimeRule：<ul><li>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重值就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</li></ul></li><li>ZoneAvoidanceRule：<ul><li>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后在对 Zone 内的多个服务做轮询。</li></ul></li><li>BestAvailableRule：<ul><li>忽略哪些短路的服务器，并选择并发数较低的服务器。</li></ul></li><li>RandomRule：<ul><li>随机选择一个可用的服务器。</li></ul></li><li>RetryRule：<ul><li>重试机制的选择逻辑</li></ul></li></ol><h5 id="通过定义-IRule-实现可以修改负载均衡规则，有两种方式："><a href="#通过定义-IRule-实现可以修改负载均衡规则，有两种方式：" class="headerlink" title="通过定义 IRule 实现可以修改负载均衡规则，有两种方式："></a>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</h5><ol><li>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span> <br>    <span class="hljs-string">NFLoadBalancerRuleClassName:com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment">#负载均衡规则</span><br></code></pre></td></tr></table></figure><h5 id="饥饿加载："><a href="#饥饿加载：" class="headerlink" title="饥饿加载："></a>饥饿加载：</h5><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。<br>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-string">ture</span> <span class="hljs-comment"># 开启饥饿加载</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 指定对userservice这个服务饥饿加载</span><br></code></pre></td></tr></table></figure><h5 id="Ribbon-总结："><a href="#Ribbon-总结：" class="headerlink" title="Ribbon 总结："></a>Ribbon 总结：</h5><ol><li>Ribbon 负载均衡规则：<ol><li>规则接口是 IRule</li><li>默认实现是 ZoneAvoidanceRule，根据 zone 选择服务列表，然后轮询</li></ol></li><li>负载均衡自定义方式：<ol><li>代码方式：配置灵活，但修改时需要重新打包发布</li><li>配置方式：只管，方便，无需重新打包发布，但是无法做全局配置</li></ol></li><li>饥饿加载：<ol><li>开启饥饿加载</li><li>指定饥饿加载的微服务名称</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2024/03/20/Java-Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/03/20/Java-Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="代理设计模式的原理"><a href="#代理设计模式的原理" class="headerlink" title="代理设计模式的原理"></a>代理设计模式的原理</h3><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><h3 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h3><ul><li><strong>静态代理</strong>：代理类和目标对象的类在编译期间确定，不利于程序扩展，且每个代理类只能为一个接口服务。</li><li><strong>动态代理</strong>：在程序运行时根据需要动态创建目标类的代理对象，更加灵活和统一。</li></ul><h3 id="动态代理的优点"><a href="#动态代理的优点" class="headerlink" title="动态代理的优点"></a>动态代理的优点</h3><p>动态代理相比静态代理，将抽象角色中声明的所有方法转移到调用处理器的一个集中方法中处理，可以更灵活和统一地处理众多方法。</p><h3 id="演示静态代理（Java代码）"><a href="#演示静态代理（Java代码）" class="headerlink" title="演示静态代理（Java代码）"></a>演示静态代理（Java代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示静态代理</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyCloth</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> ClothFactory clothFactory; <span class="hljs-comment">// 用被代理类对象进行实例化</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyCloth</span><span class="hljs-params">(ClothFactory clothFactory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clothFactory = clothFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理工厂做一些准备工作...&quot;</span>);<br>        clothFactory.produceCloth();<br>        System.out.println(<span class="hljs-string">&quot;代理工厂做一些收尾工作...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 被代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NikeClothFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;nike工厂正在生产一批衣服.....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建被代理类对象</span><br>        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">nikeClothFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NikeClothFactory</span>();<br>        <span class="hljs-comment">// 代理类对象</span><br>        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">proxyCloth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyCloth</span>(nikeClothFactory);<br>        proxyCloth.produceCloth();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="演示动态代理（Java代码）"><a href="#演示动态代理（Java代码）" class="headerlink" title="演示动态代理（Java代码）"></a>演示动态代理（Java代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span> &#123;<br>    String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>;<br>&#125;<br><br><span class="hljs-comment">// 被代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am superMan!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我喜欢吃&quot;</span> + food);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个代理类工厂，动态地创建代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br>    <span class="hljs-comment">// 调用此方法，可以创建代理类对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span> &#123; <span class="hljs-comment">// obj 就是被代理类对象</span><br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">myInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(obj);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), myInvocationHandler);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object obj; <span class="hljs-comment">// 创建被代理类对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object obj)</span> &#123; <span class="hljs-comment">// 使用构造函数为 被代理类对象赋值</span><br>        <span class="hljs-built_in">this</span>.obj = obj;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// method 即为代理类对象要调用的方法，此方法也作为了被代理类对象要调用的方法</span><br>        <span class="hljs-comment">// obj就是被代理的对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br>        <span class="hljs-comment">// 上述方法的返回值就作为当前类中的invoke（）方法的返回值</span><br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperMan</span> <span class="hljs-variable">superMan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>        <span class="hljs-comment">// 动态的创建代理类对象</span><br>        <span class="hljs-type">Human</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);<br>        <span class="hljs-comment">// 通过代理类对象调用被代理类的方法</span><br>        System.out.println(proxyInstance.getBelief());<br>        proxyInstance.eat(<span class="hljs-string">&quot;草莓仙草冻&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态代理与AOP"><a href="#动态代理与AOP" class="headerlink" title="动态代理与AOP"></a>动态代理与AOP</h3><p>动态代理是实现AOP（面向切面编程）的核心技术之一，通过动态代理可以在不修改原始代码的情况下，为对象添加额外的功能。</p><hr><h2 id="Java-8新特性"><a href="#Java-8新特性" class="headerlink" title="Java 8新特性"></a>Java 8新特性</h2><h3 id="Java-8新特性概述"><a href="#Java-8新特性概述" class="headerlink" title="Java 8新特性概述"></a>Java 8新特性概述</h3><ul><li><strong>速度更快</strong>：性能提升。</li><li><strong>代码更少</strong>：增加了新的语法，如Lambda表达式。</li><li><strong>强大的Stream API</strong>：便于数据处理。</li><li><strong>便于并行</strong>：支持并行操作。</li><li><strong>最大化减少空指针异常</strong>：引入Optional类。</li><li><strong>Nashorn引擎</strong>：允许在JVM上运行JS应用。</li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h4><p>Lambda是一个匿名函数，可以将代码像数据一样传递，使Java的表达能力更强。</p><h4 id="Lambda表达式的使用"><a href="#Lambda表达式的使用" class="headerlink" title="Lambda表达式的使用"></a>Lambda表达式的使用</h4><ul><li>格式：<code>(o1, o2) -&gt; Integer.compare(o1, o2);</code></li><li><code>-&gt;</code>左边：Lambda形参列表（接口中的抽象方法的形参列表）。</li><li><code>-&gt;</code>右边：Lambda体（重写的抽象方法的方法体）。</li></ul><h4 id="Lambda表达式的使用示例"><a href="#Lambda表达式的使用示例" class="headerlink" title="Lambda表达式的使用示例"></a>Lambda表达式的使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法格式一：无参无返回值</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);<br>        &#125;<br>    &#125;;<br>    runnable.run();<br>    System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br><br>    <span class="hljs-comment">// Lambda表达式写法</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我爱北京天安门.&quot;</span>);<br>    &#125;;<br>    r2.run();<br>&#125;<br><br><span class="hljs-comment">// 语法格式二：Lambda需要一个参数，但没有返回值</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    Consumer&lt;String&gt; con = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;;<br>    con.accept(<span class="hljs-string">&quot;谎言和誓言的区别是什么？&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br>    <span class="hljs-comment">// Lambda表达式写法</span><br>    Consumer&lt;String&gt; con2 = (String s) -&gt; &#123;<br>        System.out.println(s);<br>    &#125;;<br>    con2.accept(<span class="hljs-string">&quot;一个是听的人信了，一个是说的人信了&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 语法格式三：数据类型可以省略，因为可以由编译器推断得出，成为“类型推断”</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;<br>        System.out.println(s);<br>    &#125;;<br>    con1.accept(<span class="hljs-string">&quot;一个是听的人信了，一个是说的人信了&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);<br>    <span class="hljs-comment">// 省略类型</span><br>    Consumer&lt;String&gt; con2 = (s) -&gt; &#123;<br>        System.out.println(s);<br>    &#125;;<br>    con2.accept(<span class="hljs-string">&quot;一个是听的人信了，一个是说的人信了&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 语法格式四：Lambda若只需要一个参数时，参数的小括号可以省略</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 省略小括号</span><br>    Consumer&lt;String&gt; con2 = s -&gt; &#123;<br>        System.out.println(s);<br>    &#125;;<br>    con2.accept(<span class="hljs-string">&quot;一个是听的人信了，一个是说的人信了&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>    Comparator&lt;Integer&gt; com = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>            System.out.println(o1);<br>            System.out.println(o2);<br>            <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>        &#125;<br>    &#125;;<br>    System.out.println(com.compare(<span class="hljs-number">12</span>, <span class="hljs-number">21</span>));<br>    System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>    <span class="hljs-comment">// Lambda写法</span><br>    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;<br>        System.out.println(o1);<br>        System.out.println(o2);<br>        <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>    &#125;;<br>    System.out.println(com2.compare(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>));<br>&#125;<br><br><span class="hljs-comment">// 语法格式六：当Lambda体只有一条语句时，若有return和大括号，可以考虑省略</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> &#123;<br>    Comparator&lt;Integer&gt; com = (o1, o2) -&gt; o1.compareTo(o2);<br>    System.out.println(com.compare(<span class="hljs-number">12</span>, <span class="hljs-number">21</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h4><p>只包含一个抽象方法的接口，就是函数式接口。可以在接口上使用<code>@FunctionalInterface</code>注解来检查它是否是一个函数式接口。</p><h4 id="Java内置四大核心函数式接口"><a href="#Java内置四大核心函数式接口" class="headerlink" title="Java内置四大核心函数式接口"></a>Java内置四大核心函数式接口</h4><ul><li><strong>消费型接口</strong>：<code>Consumer&lt;T&gt;</code>，<code>void accept(T t)</code></li><li><strong>供给型接口</strong>：<code>Supplier&lt;T&gt;</code>，<code>T get()</code></li><li><strong>函数型接口</strong>：<code>Function&lt;T,R&gt;</code>，<code>R apply(T t)</code></li><li><strong>断定型接口</strong>：<code>Predicate&lt;T&gt;</code>，<code>boolean test(T t)</code></li></ul><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CentralFunctionalInterfaces</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        happyTime(<span class="hljs-number">500.0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Double&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Double aDouble)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;在天守阁消费&quot;</span> + aDouble);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);<br>        <span class="hljs-comment">// Lambda写法</span><br>        happyTime(<span class="hljs-number">400.0</span>, money -&gt; System.out.println(<span class="hljs-string">&quot;在望舒客栈消费&quot;</span> + money));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">happyTime</span><span class="hljs-params">(Double money, Consumer&lt;Double&gt; con)</span> &#123;<br>        con.accept(money);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;南京&quot;</span>, <span class="hljs-string">&quot;东京&quot;</span>, <span class="hljs-string">&quot;天津&quot;</span>, <span class="hljs-string">&quot;西京&quot;</span>);<br>        List&lt;String&gt; filterString = filterString(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>                <span class="hljs-keyword">return</span> s.contains(<span class="hljs-string">&quot;京&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(filterString);<br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        <span class="hljs-comment">// Lambda方法</span><br>        List&lt;String&gt; list1 = filterString(list, s -&gt; s.contains(<span class="hljs-string">&quot;京&quot;</span>));<br>        System.out.println(list1);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据给定的规则，过滤集合中的字符串，此规则由Predicate的方法决定</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">filterString</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span> &#123;<br>        ArrayList&lt;String&gt; filterList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            <span class="hljs-keyword">if</span> (pre.test(s))<br>                filterList.add(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> filterList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3><h4 id="方法引用基本介绍"><a href="#方法引用基本介绍" class="headerlink" title="方法引用基本介绍"></a>方法引用基本介绍</h4><p>当要传递给Lambda体的操作已经有实现的方法时，可以使用方法引用。方法引用是Lambda表达式的一种语法糖。</p><h4 id="方法引用的使用"><a href="#方法引用的使用" class="headerlink" title="方法引用的使用"></a>方法引用的使用</h4><ul><li>格式：<code>类（或对象）::方法名</code></li><li>分为三种情况：<ol><li><strong>对象::实例方法名</strong></li><li><strong>类::静态方法名</strong></li><li><strong>类::实例方法名</strong></li></ol></li></ul><h4 id="方法引用的使用示例"><a href="#方法引用的使用示例" class="headerlink" title="方法引用的使用示例"></a>方法引用的使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 情况一：对象::实例方法</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    Consumer&lt;String&gt; con = s -&gt; System.out.println(s);<br>    con.accept(<span class="hljs-string">&quot;北京&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br>    <span class="hljs-comment">// 方法引用</span><br>    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> System.out;<br>    Consumer&lt;String&gt; con2 = ps::println;<br>    con.accept(<span class="hljs-string">&quot;上海&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 情况二：类::静态方法</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);<br>    System.out.println(com1.compare(<span class="hljs-number">12</span>, <span class="hljs-number">21</span>));<br>    System.out.println(<span class="hljs-string">&quot;-----------分割线------------&quot;</span>);<br>    <span class="hljs-comment">// 方法引用</span><br>    Comparator&lt;Integer&gt; com2 = Integer::compare;<br>    System.out.println(com2.compare(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// 情况三：类::实例方法</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>    Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);<br>    System.out.println(com1.compare(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;abd&quot;</span>));<br>    <span class="hljs-comment">// 方法引用</span><br>    System.out.println(<span class="hljs-string">&quot;-----------分割线------------&quot;</span>);<br>    Comparator&lt;String&gt; com2 = String::compareTo;<br>    System.out.println(com2.compare(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>构造器引用与方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造器引用</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    Supplier&lt;Employee&gt; supplier1 = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>    System.out.println(supplier1.get());<br>    System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br>    <span class="hljs-comment">// 演示使用构造器引用</span><br>    Supplier&lt;Employee&gt; supplier2 = Employee::<span class="hljs-keyword">new</span>;<br>    System.out.println(supplier2.get());<br>&#125;<br><br><span class="hljs-comment">// 数组引用</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Function&lt;Integer, String[]&gt; function = length -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[length];<br>    String[] arr1 = function.apply(<span class="hljs-number">5</span>);<br>    System.out.println(Arrays.toString(arr1));<br>    System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>    Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="hljs-keyword">new</span>;<br>    System.out.println(Arrays.toString(fun2.apply(<span class="hljs-number">8</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h3><h4 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h4><p>Stream是Java 8中处理集合的关键抽象概念，用于操作数据源（集合、数组等）所生成的元素序列。</p><h4 id="Stream操作的三个步骤"><a href="#Stream操作的三个步骤" class="headerlink" title="Stream操作的三个步骤"></a>Stream操作的三个步骤</h4><ol><li><strong>创建Stream</strong>：通过集合、数组等方式获取一个流。</li><li><strong>中间操作</strong>：对数据源的数据进行处理，多个中间操作可以连接起来形成流水线。</li><li><strong>终止操作</strong>：执行中间操作链，并产生结果。</li></ol><h4 id="创建Stream数据源"><a href="#创建Stream数据源" class="headerlink" title="创建Stream数据源"></a>创建Stream数据源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Stream方式一：通过集合</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();<br>    Stream&lt;Employee&gt; stream = employees.stream();<br>    Stream&lt;Employee&gt; parallelStream = employees.parallelStream();<br>&#125;<br><br><span class="hljs-comment">// 创建Stream方式二：通过数组</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">78</span>&#125;;<br>    <span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(arr);<br>    Employee[] employees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1002</span>, <span class="hljs-string">&quot;Jerry&quot;</span>)&#125;;<br>    Stream&lt;Employee&gt; stream = Arrays.stream(employees);<br>&#125;<br><br><span class="hljs-comment">// 创建Stream方式三：通过Stream的of()</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建Stream方式四：创建无限流</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Stream.iterate(<span class="hljs-number">0</span>, t -&gt; t + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br>    Stream.generate(Math::random).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><ul><li><p><strong>筛选与切片</strong></p><ul><li><code>filter(Predicate p)</code>：从流中排除某些元素。</li><li><code>limit(long maxSize)</code>：截断流，使其元素不超过给定数量。</li><li><code>skip(long n)</code>：跳过前n个元素。</li><li><code>distinct()</code>：去除重复元素。</li></ul></li><li><p><strong>映射</strong></p><ul><li><code>map(Function f)</code>：将流中的每个元素映射成一个新的元素。</li><li><code>flatMap(Function f)</code>：将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul></li><li><p><strong>排序</strong></p><ul><li><code>sorted()</code>：按自然顺序排序。</li><li><code>sorted(Comparator comp)</code>：按比较器顺序排序。</li></ul></li></ul><h4 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h4><ul><li><p><strong>匹配与查找</strong></p><ul><li><code>allMatch(Predicate p)</code>：检查是否匹配所有元素。</li><li><code>anyMatch(Predicate p)</code>：检查是否至少匹配一个元素。</li><li><code>noneMatch(Predicate p)</code>：检查是否没有匹配所有元素。</li><li><code>findFirst()</code>：返回第一个元素。</li><li><code>findAny()</code>：返回任意一个元素。</li><li><code>count()</code>：返回流中元素总数。</li><li><code>max(Comparator c)</code>：返回流中最大值。</li><li><code>min(Comparator c)</code>：返回流中最小值。</li><li><code>forEach(Consumer c)</code>：内部迭代。</li></ul></li><li><p><strong>归约</strong></p><ul><li><code>reduce(T iden, BinaryOperator b)</code>：将流中元素反复结合起来，得到一个值。</li><li><code>reduce(BinaryOperator b)</code>：将流中元素反复结合起来，得到一个值。</li></ul></li><li><p><strong>收集</strong></p><ul><li><code>collect(Collector c)</code>：将流转换为其他形式，如集合。</li></ul></li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// allMatch(Predicate p) 检查是否匹配所有元素</span><br>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">allMatch</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">18</span>);<br>    System.out.println(allMatch);<br><br>    <span class="hljs-comment">// anyMatch(Predicate p) 检查是否至少匹配一个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">anyMatch</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="hljs-number">10000</span>);<br>    System.out.println(anyMatch);<br><br>    <span class="hljs-comment">// noneMatch(Predicate p) 检查是否没有匹配所有元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">noneMatch</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(employee -&gt; employee.getName().startsWith(<span class="hljs-string">&quot;雷&quot;</span>));<br>    System.out.println(noneMatch);<br><br>    <span class="hljs-comment">// findFirst() 返回第一个元素</span><br>    Optional&lt;Employee&gt; first = employees.stream().findFirst();<br>    System.out.println(first);<br><br>    <span class="hljs-comment">// findAny() 返回当前流中的任意元素</span><br>    Optional&lt;Employee&gt; any = employees.parallelStream().findAny();<br>    System.out.println(any);<br><br>    <span class="hljs-comment">// count() 返回流中元素总数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> employees.stream().filter(employee -&gt; employee.getSalary() &gt; <span class="hljs-number">3000</span>).count();<br>    System.out.println(count);<br><br>    <span class="hljs-comment">// max(Comparator c) 返回流中最大值</span><br>    Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);<br>    Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);<br>    System.out.println(maxSalary);<br><br>    <span class="hljs-comment">// min(Comparator c) 返回流中最小值</span><br>    Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));<br>    System.out.println(employee);<br><br>    <span class="hljs-comment">// forEach(Consumer c) 内部迭代</span><br>    employees.stream().forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值</span><br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br>    System.out.println(sum);<br><br>    <span class="hljs-comment">// reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值</span><br>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();<br>    Optional&lt;Double&gt; totalSalary = employees.stream().map(Employee::getSalary).reduce(Double::sum);<br>    System.out.println(totalSalary);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// collect(Collector c) 将流转换为其他形式</span><br>    List&lt;Employee&gt; employeeList = EmployeeData.getEmployees().stream().filter(e -&gt; e.getSalary() &gt; <span class="hljs-number">6000</span>).collect(Collectors.toList());<br>    employeeList.forEach(System.out::println);<br><br>    Set&lt;Employee&gt; employeeSet = EmployeeData.getEmployees().stream().filter(e -&gt; e.getSalary() &gt; <span class="hljs-number">6000</span>).collect(Collectors.toSet());<br>    employeeSet.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><h4 id="Optional类介绍"><a href="#Optional类介绍" class="headerlink" title="Optional类介绍"></a>Optional类介绍</h4><p>Optional类是一个容器类，代表一个值存在或不存在，可以避免空指针异常。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>Optional.of(T t)</code>：创建一个Optional实例，t必须非空。</li><li><code>Optional.empty()</code>：创建一个空的Optional实例。</li><li><code>Optional.ofNullable(T t)</code>：t可以为null。</li><li><code>isPresent()</code>：判断是否包含值。</li><li><code>orElse(T t)</code>：如果调用对象包含值，返回该值，否则返回t。</li><li><code>orElseGet(Supplier s)</code>：如果调用对象包含值，返回该值，否则返回s获取的值。</li><li><code>map(Function f)</code>：如果有值对其处理，并返回处理后的Optional。</li><li><code>flatMap(Function mapper)</code>：与map类似，要求返回值必须是Optional。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptionalTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Girl</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>();<br>        <span class="hljs-comment">// of(T t):保证t是非空的</span><br>        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Girl</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>();<br>        <span class="hljs-comment">// ofNullable(T t)：t可以为null</span><br>        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);<br>        System.out.println(optionalGirl);<br>        <span class="hljs-comment">// orElse(T t1):如果当前的Optional内部封装的t是非空的，则返回内部的t.</span><br>        <span class="hljs-comment">// 如果内部的t是空的，则返回orElse()方法中的参数t1.</span><br>        <span class="hljs-type">Girl</span> <span class="hljs-variable">girl1</span> <span class="hljs-operator">=</span> optionalGirl.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>));<br>        System.out.println(girl1);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用Optional类优化方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGirlName2</span><span class="hljs-params">(Boy boy)</span> &#123;<br>        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);<br>        <span class="hljs-type">Boy</span> <span class="hljs-variable">boy1</span> <span class="hljs-operator">=</span> boyOptional.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>)));<br>        <span class="hljs-type">Girl</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> boy1.getGirl();<br>        Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);<br>        <span class="hljs-type">Girl</span> <span class="hljs-variable">girl1</span> <span class="hljs-operator">=</span> girlOptional.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>));<br>        <span class="hljs-keyword">return</span> girl1.getName();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Boy</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>(<span class="hljs-string">&quot;ikura&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">girlName</span> <span class="hljs-operator">=</span> getGirlName2(boy);<br>        System.out.println(girlName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现自定义注解</title>
    <link href="/2024/03/15/Java-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/03/15/Java-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>在 springBoot 中，注解是编码时必不可少的，它可以帮助我们更方便快捷的去开发。常见的注解如：<code>@Autowired、@Slf4j、@Data</code> 等等。</p><p>然而这些注解都是别人已经封装好给我们用的，如果我们想自定义一个拥有特别功能的注解，该怎么操作呢？</p><p>看完这篇文章，给你答案～</p><p>今天以日志功能为例，灵活的运用自定义注解方便快捷的记录每个接口的日志。</p><p>在项目中，有众多的接口，如果接口报错了，该怎么去快速定位代码呢？这个时候就要用到日志了。当接口接收到请求的时候，我希望可以记录下来这个接口的各种信息。比如请求时间、请求参数，结束时间等，还可以在接口开始和结束的时候加一个标记，方便出现报错或者 bug 的时候可以快速定位到是哪个接口出了问题。</p><p>接下来就用日志系统来介绍自定义注解～</p><hr><h2 id="不使用注解"><a href="#不使用注解" class="headerlink" title="不使用注解"></a>不使用注解</h2><p>我们可以在接口方法的开头和结尾加一行日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycontroller</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycontroller**********get********start&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;执行了get方法&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;Mycontroller**********get********end&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p>   <img src="/img/articles/self/1.png"> </p><p>方法的首尾两行都会有一个日志输出，把这个方法的所有运行包在了日志里面，如果个方法出现了问题，就很容易定位到这里了。</p><p>比如我故意写一个报错：<code>int i = 2/0;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;Mycontroller**********get********start&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>/<span class="hljs-number">0</span>;<br>    System.out.println(<span class="hljs-string">&quot;执行了get方法&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;Mycontroller**********get********end&quot;</span>);<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么输出结果如下：</p><p>   <img src="/img/articles/self/2.png"> </p><p>可以看到报错的上一行日志定位了 <code>get</code> 方法。我们只需在 <code>get</code> 方法里面找问题就好了。</p><p>每个方法的首尾都要这样写一个日志记录，代码就会<strong>大量冗余</strong>。想获取入参的话，还得再写一段代码来实现，并且根据每个方法的入参数量、类型的不同，可能代码也要相应的变动。</p><p>既然这个是重复性的工作，而且逻辑上都是：<strong>在方法开始之前和方法结束之后做一个标记</strong>。那么我们能不能把这一部分抽取出来，只写一次代码，就能作用在每一个方法上面呢？</p><p>毫无疑问，答案是<strong>可以</strong>！</p><hr><h2 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h2><p>在一个事情的开始和结束插入另一个事情，很容易联想到 Spring 的一个重要特性 ——<strong>AOP</strong>。</p><blockquote><p>Spring 的 AOP（Aspect-Oriented Programming，面向切面编程）是 Spring 框架中的一个重要特性，用于将横切关注点从应用程序的主业务逻辑中分离出来，使得关注点的代码可以被模块化、重用，并且与主业务逻辑解耦。</p></blockquote><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>使用 <code>@interface</code> 关键字定义一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LogInfo &#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>在自定义注解中，根据需要标注元注解，如果没有特定需求的话<strong>也可以不标注</strong>。</p><p>一共有以下 5 个元注解：</p><ol><li><p>@Retention</p><p>（保留策略）：</p><ul><li><code>RetentionPolicy.SOURCE</code>：注解仅存在于源代码中，在编译时会被丢弃。这种类型的注解通常用于提供编译时的辅助信息，不会对运行时产生影响。</li><li><code>RetentionPolicy.CLASS</code>：注解存在于编译后的字节码文件中，但在运行时会被丢弃。这种类型的注解可以在编译时对代码进行一些处理，但不会影响程序运行时的行为。</li><li><code>RetentionPolicy.RUNTIME</code>：注解在运行时可以通过反射获取到。这种类型的注解可以在运行时对程序的行为进行动态调整，例如在 AOP（面向切面编程）中经常使用。</li></ul></li><li><p>@Target</p><p>（目标类型）：</p><ul><li><code>ElementType.METHOD</code>：指定注解可以应用于方法。</li><li><code>ElementType.FIELD</code>：指定注解可以应用于字段。</li><li><code>ElementType.TYPE</code>：指定注解可以应用于类、接口（包括注解类型）。</li><li><code>ElementType.PARAMETER</code>：指定注解可以应用于参数。</li><li><code>ElementType.CONSTRUCTOR</code>：指定注解可以应用于构造函数等。</li></ul></li><li><p>@Documented</p><p>（文档化）：</p><ul><li>当一个注解被 @Documented 修饰时，这个注解将会包含在 Javadoc 生成的文档中，使得注解的信息可以被文档化展示。</li></ul></li><li><p>@Inherited</p><p>（继承性）：</p><ul><li>如果一个注解被 @Inherited 修饰，那么子类会继承父类的该注解。这对于一些需要在继承关系中传递注解的情况非常有用。</li></ul></li><li><p>@Repeatable</p><p>（可重复性）：</p><ul><li>允许一个注解在同一个目标上被多次应用，而不需要使用容器注解来包裹多个相同的注解实例。这样可以使代码更加简洁和易读。</li></ul></li></ol><h3 id="引-AOP-依赖"><a href="#引-AOP-依赖" class="headerlink" title="引 AOP 依赖"></a>引 AOP 依赖</h3><p>要实现 AOP 自定义注解，第一步先引入 AOP 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AOP--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写-AOP-程序"><a href="#编写-AOP-程序" class="headerlink" title="编写 AOP 程序"></a>编写 AOP 程序</h3><p>新建一个 AOP 类，针对于特定方法根据业务需要进行编程 (加 @Aspect 注解声明为 AOP 类）</p><p>这个类中，我们要实现自定义注解的功能，比如在方法开始之前，做一个标记，记录该方法的入参，方法结束之后再做一个标记。</p><p>新建一个 AOP 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAOP</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@Aspect 注解：标记该类为切面类，Spring AOP 会自动识别带有 <code>@Aspect</code> 注解的类，并将其视为切面，然后根据定义的通知和切点来实现横切逻辑。</p><p>@Component：用来表示一个受 Spring 容器管理的组件的注解。可以让 Spring 自动扫描并识别被注解的类，然后将其实例化并加入到 Spring 容器中管理。</p></blockquote><p>写一个在<strong>接口执行之前</strong>要执行的逻辑方法：</p><p>用 <code>@Before</code> 注解标注，里面的 <code>@annotation</code> 是用于定义切点表达式的一种特殊用法，</p><p>下列代码中 <code>@Before(&quot;@annotation(LogInfo)&quot;)</code> 表示在执行<strong>被自定义注解标记的方法前</strong>执行 <code>logBefore方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAOP</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;@annotation(LogInfo)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-comment">// 获取方法所在类的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fullClassName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getDeclaringTypeName();<br> <br>        <span class="hljs-comment">// 获取方法名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br> <br>        <span class="hljs-comment">// 提取类名的最后一部分</span><br>        <span class="hljs-comment">// 比如：com.pidanxia.aop.LogAOP，只拿LogAOP</span><br>        String[] classNameParts = fullClassName.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> classNameParts[classNameParts.length - <span class="hljs-number">1</span>];<br> <br>        <span class="hljs-comment">// 在方法执行前记录日志</span><br>        log.info(className + <span class="hljs-string">&quot;****************&quot;</span> + methodName + <span class="hljs-string">&quot;****************start&quot;</span>);<br> <br>        <span class="hljs-comment">// 获取参数列表</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-comment">// 入参集合</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 获取方法参数名称</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">methodSignature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>        String[] parameterNames = methodSignature.getParameterNames();<br>        <span class="hljs-comment">// 输出入参值</span><br>        <span class="hljs-keyword">if</span> (parameterNames != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (parameterNames.length &gt; i) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">paramName</span> <span class="hljs-operator">=</span> parameterNames[i];<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">paramValue</span> <span class="hljs-operator">=</span> args[i];<br>                    map.put(paramName, paramValue);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(map);<br>        log.info(<span class="hljs-string">&quot;\n入参：&quot;</span> + json);<br>    &#125;<br></code></pre></td></tr></table></figure><p>之前有了，理应也要有一个之后的。写一个在<strong>接口执行之后</strong>要执行的逻辑方法：</p><p>用 <code>@After</code> 注解标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@After(&quot;@annotation(LogInfo)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfter</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>    <span class="hljs-comment">// 获取方法所在类的名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fullClassName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getDeclaringTypeName();<br> <br>    <span class="hljs-comment">// 获取方法名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br> <br>    <span class="hljs-comment">// 提取类名的最后一部分</span><br>    String[] classNameParts = fullClassName.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> classNameParts[classNameParts.length - <span class="hljs-number">1</span>];<br> <br>    <span class="hljs-comment">// 在方法执行后记录日志</span><br>    log.info(className + <span class="hljs-string">&quot;****************&quot;</span> + methodName + <span class="hljs-string">&quot;****************end&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用自定义注解-1"><a href="#使用自定义注解-1" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h3><p>在接口处使用自定义注解标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@LogInfo</span><br><span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;执行了get方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="/img/articles/self/3.png"> </p><p>即使我们没有在接口方法中写任何的日志逻辑，只要标记了注解，就会自动调用注解方法！</p><h3 id="整合成-Around-注解"><a href="#整合成-Around-注解" class="headerlink" title="整合成 @Around 注解"></a>整合成 <code>@Around</code> 注解</h3><p>有了之前，有了之后，还会有一个包围的注解！</p><p>上面的 <code>@Before</code> 和 <code>@After</code> 可以合并为一个注解：<code>@Around</code></p><p>一般开发中都是使用 <code>@Around</code> 注解比较多，因为这样只用写一个注解方法就可以了。</p><p>使用方法也很简单，就是用 <code>Object result = point.proceed();</code> 来隔开之前和之后执行的两部分。</p><p><code>Object result = point.proceed();</code> 语句就是执行接口方法的意思，执行完这条语句，接口方法就执行完了。</p><p><strong>特别注意：</strong>用 <code>@Around</code> 注解标注的方法入参必须是：**<code>ProceedingJoinPoint</code> 类型**的，因为 <code>proceed()</code> 方法是在 <code>ProceedingJoinPoint</code> 接口中定义的，<code>JoinPoint</code> 接口中没有定义。</p><p>把之前的 <code>logBefore方法</code>和 <code>logAfter方法</code>都注释掉，然后写一个新的 <code>logAround方法</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;@annotation(LogInfo)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br> <br>    ……  <span class="hljs-comment">//这里代表logBefore方法的代码，一模一样拷贝过来即可</span><br> <br>    <span class="hljs-comment">// 执行原方法</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br> <br>    <span class="hljs-comment">// 在方法执行后记录日志</span><br>    log.info(className + <span class="hljs-string">&quot;****************&quot;</span> + methodName + <span class="hljs-string">&quot;****************end&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>然后再来请求一下接口，看看控制台输出：</p><p>   <img src="/img/articles/self/4.png"> </p><p>可以看到效果是跟之前的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
